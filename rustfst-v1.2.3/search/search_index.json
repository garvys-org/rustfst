{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"rustfst-python","text":""},{"location":"#introduction","title":"Introduction","text":"<p>Rust implementation of Weighted Finite States Transducers.</p> <p>Rustfst is a library for constructing, combining, optimizing, and searching weighted finite-state transducers (FSTs). Weighted finite-state transducers are automata where each transition has an input label, an output label, and a weight. The more familiar finite-state acceptor is represented as a transducer with each transition's input and output label equal. Finite-state acceptors are used to represent sets of strings (specifically, regular or rational sets); finite-state transducers are used to represent binary relations between pairs of strings (specifically, rational transductions). The weights can be used to represent the cost of taking a particular transition.</p> <p>FSTs have key applications in speech recognition and synthesis, machine translation, optical character recognition, pattern matching, string processing, machine learning, information extraction and retrieval among others. Often a weighted transducer is used to represent a probabilistic model (e.g., an n-gram model, pronunciation model). FSTs can be optimized by determinization and minimization, models can be applied to hypothesis sets (also represented as automata) or cascaded by finite-state composition, and the best results can be selected by shortest-path algorithms.</p> <p></p>"},{"location":"#naming","title":"Naming","text":"<ul> <li><code>rustfst</code> is the Rust re-implementation of <code>Openfst</code>.</li> <li><code>rustfst-python</code> is a python biding on top of <code>rustfst</code>.</li> </ul>"},{"location":"#references","title":"References","text":"<p>Implementation heavily inspired from Mehryar Mohri's, Cyril Allauzen's and Michael Riley's work :</p> <ul> <li>Weighted automata algorithms</li> <li>The design principles of a weighted finite-state transducer library</li> <li>OpenFst: A general and efficient weighted finite-state transducer library</li> <li>Weighted finite-state transducers in speech recognition</li> </ul>"},{"location":"rustfst/algorithms/","title":"algorithms","text":""},{"location":"rustfst/algorithms/#rustfst.algorithms-classes","title":"Classes","text":""},{"location":"rustfst/algorithms/#rustfst.algorithms-functions","title":"Functions","text":""},{"location":"rustfst/algorithms/#rustfst.algorithms.acceptor","title":"<code>acceptor(astring: str, symbol_table: SymbolTable, weight: Optional[float] = None) -&gt; VectorFst</code>","text":"<p>Creates an acceptor from a string. This function creates a FST which accepts its input with a fixed weight (defaulting to semiring One). Args:   astring: The input string.   weight: A Weight or weight string indicating the desired path weight. If     omitted or null, the path weight is set to semiring One.   symbol_table: SymbolTable to be used to encode the string. Returns:   An FST acceptor.</p> Source code in <code>rustfst/algorithms/__init__.py</code> <pre><code>def acceptor(\n    astring: str, symbol_table: SymbolTable, weight: Optional[float] = None\n) -&gt; VectorFst:\n    \"\"\"\n    Creates an acceptor from a string.\n    This function creates a FST which accepts its input with a fixed weight\n    (defaulting to semiring One).\n    Args:\n      astring: The input string.\n      weight: A Weight or weight string indicating the desired path weight. If\n        omitted or null, the path weight is set to semiring One.\n      symbol_table: SymbolTable to be used to encode the string.\n    Returns:\n      An FST acceptor.\n    \"\"\"\n    if weight is None:\n        weight = weight_one()\n\n    acceptor_fst_ptr = ctypes.pointer(ctypes.c_void_p())\n    ret_code = lib.utils_string_to_acceptor(\n        astring.encode(\"utf-8\"),\n        symbol_table.ptr,\n        ctypes.c_float(weight),\n        ctypes.byref(acceptor_fst_ptr),\n    )\n    err_msg = \"Error creating acceptor FST\"\n    check_ffi_error(ret_code, err_msg)\n    return VectorFst(ptr=acceptor_fst_ptr)\n</code></pre>"},{"location":"rustfst/algorithms/#rustfst.algorithms.transducer","title":"<code>transducer(istring: str, ostring: str, isymt: SymbolTable, osymt: SymbolTable, weight: Optional[float] = None) -&gt; VectorFst</code>","text":"<p>Creates a transducer from a pair of strings or acceptor FSTs. This function creates a FST which transduces from the first string to the second with a fixed weight (defaulting to semiring One). Args:   istring: The input string   ostring: The output string   weight: A Weight as float.   isymt: SymbolTable to be used to encode the string.   osymt: SymbolTable to be used to encode the string. Returns:   An FST transducer.</p> Source code in <code>rustfst/algorithms/__init__.py</code> <pre><code>def transducer(\n    istring: str,\n    ostring: str,\n    isymt: SymbolTable,\n    osymt: SymbolTable,\n    weight: Optional[float] = None,\n) -&gt; VectorFst:\n    \"\"\"\n    Creates a transducer from a pair of strings or acceptor FSTs.\n    This function creates a FST which transduces from the first string to\n    the second with a fixed weight (defaulting to semiring One).\n    Args:\n      istring: The input string\n      ostring: The output string\n      weight: A Weight as float.\n      isymt: SymbolTable to be used to encode the string.\n      osymt: SymbolTable to be used to encode the string.\n    Returns:\n      An FST transducer.\n    \"\"\"\n\n    if weight is None:\n        weight = weight_one()\n\n    transducer_fst_ptr = ctypes.c_void_p()\n    ret_code = lib.utils_string_to_transducer(\n        istring.encode(\"utf-8\"),\n        ostring.encode(\"utf-8\"),\n        isymt.ptr,\n        osymt.ptr,\n        ctypes.c_float(weight),\n        ctypes.byref(transducer_fst_ptr),\n    )\n    err_msg = \"Error creating tranducer FST\"\n    check_ffi_error(ret_code, err_msg)\n\n    return VectorFst(ptr=transducer_fst_ptr)\n</code></pre>"},{"location":"rustfst/algorithms/#rustfst.algorithms.epsilon_machine","title":"<code>epsilon_machine(weight: Optional[float] = None) -&gt; VectorFst</code>","text":"<p>Constructs a single-state, no-arc FST accepting epsilon. This function creates an unweighted FST with a single state which is both initial and final. Args:   weight: A Weight. Default semiring One. Returns:   An FST.</p> Source code in <code>rustfst/algorithms/__init__.py</code> <pre><code>def epsilon_machine(weight: Optional[float] = None) -&gt; VectorFst:\n    \"\"\"\n    Constructs a single-state, no-arc FST accepting epsilon.\n    This function creates an unweighted FST with a single state which is both\n    initial and final.\n    Args:\n      weight: A Weight. Default semiring One.\n    Returns:\n      An FST.\n    \"\"\"\n    if weight is None:\n        weight = weight_one()\n    fst = VectorFst()\n    state = fst.add_state()\n    fst.set_start(state)\n    fst.set_final(state, weight)\n\n    return fst\n</code></pre>"},{"location":"rustfst/algorithms/#rustfst.algorithms-modules","title":"Modules","text":""},{"location":"rustfst/algorithms/#rustfst.algorithms.compose","title":"<code>compose</code>","text":""},{"location":"rustfst/algorithms/#rustfst.algorithms.compose-classes","title":"Classes","text":""},{"location":"rustfst/algorithms/#rustfst.algorithms.compose.ComposeConfig","title":"<code>ComposeConfig</code>","text":"<p>Configuration for compose operation.</p> <p>Parameters:</p> Name Type Description Default <code>compose_filter</code> <code>ComposeFilter</code> <p>Filter which determines allowable matches during               composition operation.</p> <code>AUTOFILTER</code> <code>connect</code> <code>bool</code> <p>Connect the resulting FST after composition.</p> <code>True</code> <code>matcher1_config</code> <code>Optional[MatcherConfig]</code> <p>Matcher configuration for left-hand FST.</p> <code>None</code> <code>matcher2_config</code> <code>Optional[MatcherConfig]</code> <p>Matcher configuration for right-hand FST.</p> <code>None</code> Source code in <code>rustfst/algorithms/compose.py</code> <pre><code>class ComposeConfig:\n    \"\"\"\n    Configuration for compose operation.\n\n    Args:\n      compose_filter: Filter which determines allowable matches during\n                      composition operation.\n      connect: Connect the resulting FST after composition.\n      matcher1_config: Matcher configuration for left-hand FST.\n      matcher2_config: Matcher configuration for right-hand FST.\n    \"\"\"\n\n    def __init__(\n        self,\n        compose_filter: ComposeFilter = ComposeFilter.AUTOFILTER,\n        connect: bool = True,\n        matcher1_config: Optional[MatcherConfig] = None,\n        matcher2_config: Optional[MatcherConfig] = None,\n    ):\n        config = ctypes.pointer(ctypes.c_void_p())\n\n        m1_ptr = None\n        if matcher1_config is not None:\n            m1_ptr = matcher1_config.ptr\n        m2_ptr = None\n\n        if matcher2_config is not None:\n            m2_ptr = matcher2_config.ptr\n\n        ret_code = lib.fst_compose_config_new(\n            ctypes.c_size_t(compose_filter.value),\n            ctypes.c_bool(connect),\n            m1_ptr,\n            m2_ptr,\n            ctypes.byref(config),\n        )\n        err_msg = \"Error creating ComposeConfig\"\n        check_ffi_error(ret_code, err_msg)\n        self.ptr = config\n\n    def __del__(self):\n        lib.fst_compose_config_destroy(self.ptr)\n</code></pre>"},{"location":"rustfst/algorithms/#rustfst.algorithms.compose-functions","title":"Functions","text":""},{"location":"rustfst/algorithms/#rustfst.algorithms.compose.compose","title":"<code>compose(fst: VectorFst, other_fst: VectorFst) -&gt; VectorFst</code>","text":"<p>Compute the composition of two FSTs. Args:     fst: Left fst.     other_fst: Right fst. Returns:     Resulting fst.</p> Source code in <code>rustfst/algorithms/compose.py</code> <pre><code>def compose(fst: VectorFst, other_fst: VectorFst) -&gt; VectorFst:\n    \"\"\"\n    Compute the composition of two FSTs.\n    Args:\n        fst: Left fst.\n        other_fst: Right fst.\n    Returns:\n        Resulting fst.\n    \"\"\"\n\n    composition = ctypes.pointer(ctypes.c_void_p())\n    ret_code = lib.fst_compose(fst.ptr, other_fst.ptr, ctypes.byref(composition))\n    err_msg = \"Error Composing FSTs\"\n    check_ffi_error(ret_code, err_msg)\n\n    return VectorFst(ptr=composition)\n</code></pre>"},{"location":"rustfst/algorithms/#rustfst.algorithms.compose.compose_with_config","title":"<code>compose_with_config(fst: VectorFst, other_fst: VectorFst, config: ComposeConfig) -&gt; VectorFst</code>","text":"<p>Compute the composition of two FSTs parametrized with a config. Args:     fst: Left fst.     other_fst: Right fst.     config: Config parameters of the composition. Returns:     Resulting fst.</p> Source code in <code>rustfst/algorithms/compose.py</code> <pre><code>def compose_with_config(\n    fst: VectorFst, other_fst: VectorFst, config: ComposeConfig\n) -&gt; VectorFst:\n    \"\"\"\n    Compute the composition of two FSTs parametrized with a config.\n    Args:\n        fst: Left fst.\n        other_fst: Right fst.\n        config: Config parameters of the composition.\n    Returns:\n        Resulting fst.\n    \"\"\"\n\n    composition = ctypes.pointer(ctypes.c_void_p())\n    ret_code = lib.fst_compose_with_config(\n        fst.ptr, other_fst.ptr, config.ptr, ctypes.byref(composition)\n    )\n    err_msg = \"Error Composing FSTs\"\n    check_ffi_error(ret_code, err_msg)\n\n    return VectorFst(ptr=composition)\n</code></pre>"},{"location":"rustfst/algorithms/#rustfst.algorithms.concat","title":"<code>concat</code>","text":""},{"location":"rustfst/algorithms/#rustfst.algorithms.concat-classes","title":"Classes","text":""},{"location":"rustfst/algorithms/#rustfst.algorithms.concat-functions","title":"Functions","text":""},{"location":"rustfst/algorithms/#rustfst.algorithms.concat.concat","title":"<code>concat(fst: VectorFst, other_fst: VectorFst) -&gt; VectorFst</code>","text":"<p>Compute the concatenation of two Fsts. Args:     fst: Left fst.     other_fst: Right fst. Returns:     Resulting fst.</p> Source code in <code>rustfst/algorithms/concat.py</code> <pre><code>def concat(fst: VectorFst, other_fst: VectorFst) -&gt; VectorFst:\n    \"\"\"\n    Compute the concatenation of two Fsts.\n    Args:\n        fst: Left fst.\n        other_fst: Right fst.\n    Returns:\n        Resulting fst.\n    \"\"\"\n\n    ret_code = lib.fst_concat(fst.ptr, other_fst.ptr)\n    err_msg = \"Error during concat\"\n    check_ffi_error(ret_code, err_msg)\n\n    return fst\n</code></pre>"},{"location":"rustfst/algorithms/#rustfst.algorithms.concat.concat_list","title":"<code>concat_list(fsts: List[VectorFst]) -&gt; VectorFst</code>","text":"<p>Compute the concatenation of a list of Fsts. Args:     fsts: List of Fsts to concatenated</p> <p>Returns:</p> Type Description <code>VectorFst</code> <p>The resulting concatenated Fst.</p> Source code in <code>rustfst/algorithms/concat.py</code> <pre><code>def concat_list(fsts: List[VectorFst]) -&gt; VectorFst:\n    \"\"\"\n    Compute the concatenation of a list of Fsts.\n    Args:\n        fsts: List of Fsts to concatenated\n\n    Returns:\n        The resulting concatenated Fst.\n    \"\"\"\n    if not fsts:\n        raise ValueError(\"fsts must be at least of len 1\")\n    fsts = [f.copy() for f in fsts]\n    concatenated = fsts[0]\n    for f in fsts[1:]:\n        concatenated = concatenated.concat(f)\n    return concatenated\n</code></pre>"},{"location":"rustfst/algorithms/#rustfst.algorithms.connect","title":"<code>connect</code>","text":""},{"location":"rustfst/algorithms/#rustfst.algorithms.connect-classes","title":"Classes","text":""},{"location":"rustfst/algorithms/#rustfst.algorithms.connect-functions","title":"Functions","text":""},{"location":"rustfst/algorithms/#rustfst.algorithms.connect.connect","title":"<code>connect(fst: VectorFst) -&gt; VectorFst</code>","text":"<p>This operation trims an Fst in-place, removing states and trs that are not on successful paths.</p> <p>Examples :</p> <ul> <li>Input :</li> </ul> <p></p> <ul> <li>Output :</li> </ul> <p></p> Returns <p>fst</p> Source code in <code>rustfst/algorithms/connect.py</code> <pre><code>def connect(fst: VectorFst) -&gt; VectorFst:\n    \"\"\"\n    This operation trims an Fst in-place, removing states and trs that are not on\n    successful paths.\n\n    Examples :\n\n    - Input :\n\n    ![connect_in](https://raw.githubusercontent.com/Garvys/rustfst-images-doc/master/images/connect_in.svg?sanitize=true)\n\n    - Output :\n\n    ![connect_out](https://raw.githubusercontent.com/Garvys/rustfst-images-doc/master/images/connect_out.svg?sanitize=true)\n\n    Returns :\n        fst\n    \"\"\"\n\n    ret_code = lib.fst_connect(fst.ptr)\n    err_msg = \"Error during connect\"\n    check_ffi_error(ret_code, err_msg)\n\n    return fst\n</code></pre>"},{"location":"rustfst/algorithms/#rustfst.algorithms.determinize","title":"<code>determinize</code>","text":""},{"location":"rustfst/algorithms/#rustfst.algorithms.determinize-classes","title":"Classes","text":""},{"location":"rustfst/algorithms/#rustfst.algorithms.determinize.DeterminizeType","title":"<code>DeterminizeType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enumeration defining the type of the determinization to perform.</p> Source code in <code>rustfst/algorithms/determinize.py</code> <pre><code>class DeterminizeType(Enum):\n    \"\"\"\n    Enumeration defining the type of the determinization to perform.\n    \"\"\"\n\n    DETERMINIZE_FUNCTIONAL = 0\n    \"\"\"\n    Input transducer is known to be functional (or error).\n    \"\"\"\n    DETERMINIZE_NON_FUNCTIONAL = 1\n    \"\"\"\n    Input transducer is NOT known to be functional.\n    \"\"\"\n    DETERMINIZE_DISAMBIGUATE = 2\n    \"\"\"\n    Input transducer is not known to be functional but only keep the min of\n    of ambiguous outputs.\n    \"\"\"\n</code></pre> Attributes <code>DETERMINIZE_FUNCTIONAL = 0</code> <code>class-attribute</code> <code>instance-attribute</code> <p>Input transducer is known to be functional (or error).</p> <code>DETERMINIZE_NON_FUNCTIONAL = 1</code> <code>class-attribute</code> <code>instance-attribute</code> <p>Input transducer is NOT known to be functional.</p> <code>DETERMINIZE_DISAMBIGUATE = 2</code> <code>class-attribute</code> <code>instance-attribute</code> <p>Input transducer is not known to be functional but only keep the min of of ambiguous outputs.</p>"},{"location":"rustfst/algorithms/#rustfst.algorithms.determinize.DeterminizeConfig","title":"<code>DeterminizeConfig</code>","text":"<p>Struct containing the parameters controlling the determinization algorithm.</p> Source code in <code>rustfst/algorithms/determinize.py</code> <pre><code>class DeterminizeConfig:\n    \"\"\"\n    Struct containing the parameters controlling the determinization algorithm.\n    \"\"\"\n\n    def __init__(self, det_type: DeterminizeType, delta: Optional[float] = None):\n        \"\"\"\n        Creates the configuration object.\n        Args:\n            det_type: Type of determinization to perform.\n            delta:\n        \"\"\"\n        if delta is None:\n            delta = KDELTA\n\n        config = ctypes.pointer(ctypes.c_void_p())\n        ret_code = lib.fst_determinize_config_new(\n            ctypes.c_float(delta),\n            ctypes.c_size_t(det_type.value),\n            ctypes.byref(config),\n        )\n        err_msg = \"Error creating DeterminizeConfig\"\n        check_ffi_error(ret_code, err_msg)\n        self.ptr = config\n</code></pre> Functions <code>__init__(det_type: DeterminizeType, delta: Optional[float] = None)</code> <p>Creates the configuration object. Args:     det_type: Type of determinization to perform.     delta:</p> Source code in <code>rustfst/algorithms/determinize.py</code> <pre><code>def __init__(self, det_type: DeterminizeType, delta: Optional[float] = None):\n    \"\"\"\n    Creates the configuration object.\n    Args:\n        det_type: Type of determinization to perform.\n        delta:\n    \"\"\"\n    if delta is None:\n        delta = KDELTA\n\n    config = ctypes.pointer(ctypes.c_void_p())\n    ret_code = lib.fst_determinize_config_new(\n        ctypes.c_float(delta),\n        ctypes.c_size_t(det_type.value),\n        ctypes.byref(config),\n    )\n    err_msg = \"Error creating DeterminizeConfig\"\n    check_ffi_error(ret_code, err_msg)\n    self.ptr = config\n</code></pre>"},{"location":"rustfst/algorithms/#rustfst.algorithms.determinize-functions","title":"Functions","text":""},{"location":"rustfst/algorithms/#rustfst.algorithms.determinize.determinize","title":"<code>determinize(fst: VectorFst) -&gt; VectorFst</code>","text":"<p>Make an Fst deterministic Args:     fst: The Fst to make deterministic. Returns:     The resulting Fst.</p> Source code in <code>rustfst/algorithms/determinize.py</code> <pre><code>def determinize(fst: VectorFst) -&gt; VectorFst:\n    \"\"\"\n    Make an Fst deterministic\n    Args:\n        fst: The Fst to make deterministic.\n    Returns:\n        The resulting Fst.\n    \"\"\"\n    det_fst = ctypes.pointer(ctypes.c_void_p())\n    ret_code = lib.fst_determinize(fst.ptr, ctypes.byref(det_fst))\n    err_msg = \"Error during determinization\"\n    check_ffi_error(ret_code, err_msg)\n\n    return VectorFst(ptr=det_fst)\n</code></pre>"},{"location":"rustfst/algorithms/#rustfst.algorithms.determinize.determinize_with_config","title":"<code>determinize_with_config(fst: VectorFst, config: DeterminizeConfig) -&gt; VectorFst</code>","text":"<p>Make an Fst deterministic Args:     fst: The Fst to make deterministic.     config: Configuration of the determinization algorithm to use. Returns:     The resulting Fst.</p> Source code in <code>rustfst/algorithms/determinize.py</code> <pre><code>def determinize_with_config(fst: VectorFst, config: DeterminizeConfig) -&gt; VectorFst:\n    \"\"\"\n    Make an Fst deterministic\n    Args:\n        fst: The Fst to make deterministic.\n        config: Configuration of the determinization algorithm to use.\n    Returns:\n        The resulting Fst.\n    \"\"\"\n    det_fst = ctypes.pointer(ctypes.c_void_p())\n    ret_code = lib.fst_determinize_with_config(\n        fst.ptr, config.ptr, ctypes.byref(det_fst)\n    )\n    err_msg = \"Error during determinization\"\n    check_ffi_error(ret_code, err_msg)\n\n    return VectorFst(ptr=det_fst)\n</code></pre>"},{"location":"rustfst/algorithms/#rustfst.algorithms.inversion","title":"<code>inversion</code>","text":""},{"location":"rustfst/algorithms/#rustfst.algorithms.inversion-classes","title":"Classes","text":""},{"location":"rustfst/algorithms/#rustfst.algorithms.inversion-functions","title":"Functions","text":""},{"location":"rustfst/algorithms/#rustfst.algorithms.inversion.invert","title":"<code>invert(fst: VectorFst) -&gt; VectorFst</code>","text":"<p>Invert the transduction corresponding to an FST by exchanging the FST's input and output labels in-place.</p> <p>Parameters:</p> Name Type Description Default <code>fst</code> <code>VectorFst</code> <p>FST to be inverted.</p> required <p>Returns:    self</p> Source code in <code>rustfst/algorithms/inversion.py</code> <pre><code>def invert(fst: VectorFst) -&gt; VectorFst:\n    \"\"\"\n    Invert the transduction corresponding to an FST by exchanging the\n    FST's input and output labels in-place.\n\n    Args:\n       fst: FST to be inverted.\n    Returns:\n       self\n    \"\"\"\n\n    ret_code = lib.fst_invert(fst.ptr)\n    err_msg = \"Error during invert\"\n    check_ffi_error(ret_code, err_msg)\n\n    return fst\n</code></pre>"},{"location":"rustfst/algorithms/#rustfst.algorithms.isomorphic","title":"<code>isomorphic</code>","text":""},{"location":"rustfst/algorithms/#rustfst.algorithms.isomorphic-classes","title":"Classes","text":""},{"location":"rustfst/algorithms/#rustfst.algorithms.isomorphic-functions","title":"Functions","text":""},{"location":"rustfst/algorithms/#rustfst.algorithms.isomorphic.isomorphic","title":"<code>isomorphic(fst: VectorFst, other_fst: VectorFst) -&gt; bool</code>","text":"<p>Check if two Fsts are isomorphic. Args:     fst: First Fst.     other_fst: Second Fst. Returns:     Whether both Fsts are equal.</p> Source code in <code>rustfst/algorithms/isomorphic.py</code> <pre><code>def isomorphic(fst: VectorFst, other_fst: VectorFst) -&gt; bool:\n    \"\"\"\n    Check if two Fsts are isomorphic.\n    Args:\n        fst: First Fst.\n        other_fst: Second Fst.\n    Returns:\n        Whether both Fsts are equal.\n    \"\"\"\n\n    is_isomorphic = ctypes.c_size_t()\n    ret_code = lib.fst_isomorphic(fst.ptr, other_fst.ptr, ctypes.byref(is_isomorphic))\n    err_msg = \"Error checking isomorphic FSTs\"\n    check_ffi_error(ret_code, err_msg)\n\n    return bool(is_isomorphic.value)\n</code></pre>"},{"location":"rustfst/algorithms/#rustfst.algorithms.minimize","title":"<code>minimize</code>","text":""},{"location":"rustfst/algorithms/#rustfst.algorithms.minimize-classes","title":"Classes","text":""},{"location":"rustfst/algorithms/#rustfst.algorithms.minimize.MinimizeConfig","title":"<code>MinimizeConfig</code>","text":"<p>Configuration for the minimization operation.</p> Source code in <code>rustfst/algorithms/minimize.py</code> <pre><code>class MinimizeConfig:\n    \"\"\"\n    Configuration for the minimization operation.\n    \"\"\"\n\n    def __init__(self, delta=None, allow_nondet=False):\n        if delta is None:\n            delta = KSHORTESTDELTA\n        config = ctypes.pointer(ctypes.c_void_p())\n        ret_code = lib.fst_minimize_config_new(\n            ctypes.c_float(delta),\n            ctypes.c_bool(allow_nondet),\n            ctypes.byref(config),\n        )\n        err_msg = \"Error creating MinimizeConfig\"\n        check_ffi_error(ret_code, err_msg)\n        self.ptr = config\n</code></pre>"},{"location":"rustfst/algorithms/#rustfst.algorithms.minimize-functions","title":"Functions","text":""},{"location":"rustfst/algorithms/#rustfst.algorithms.minimize.minimize","title":"<code>minimize(fst: VectorFst) -&gt; VectorFst</code>","text":"<p>Minimize an FST in-place Params:   fst: Fst Returns:   fst</p> Source code in <code>rustfst/algorithms/minimize.py</code> <pre><code>def minimize(fst: VectorFst) -&gt; VectorFst:\n    \"\"\"\n    Minimize an FST in-place\n    Params:\n      fst: Fst\n    Returns:\n      fst\n    \"\"\"\n    ret_code = lib.fst_minimize(fst.ptr)\n    err_msg = \"Error while minimizing FST\"\n    check_ffi_error(ret_code, err_msg)\n\n    return fst\n</code></pre>"},{"location":"rustfst/algorithms/#rustfst.algorithms.minimize.minimize_with_config","title":"<code>minimize_with_config(fst: VectorFst, config: MinimizeConfig) -&gt; VectorFst</code>","text":"<p>Minimize an FST in-place Params:   fst: Fst   config: Configuration Returns:   fst</p> Source code in <code>rustfst/algorithms/minimize.py</code> <pre><code>def minimize_with_config(fst: VectorFst, config: MinimizeConfig) -&gt; VectorFst:\n    \"\"\"\n    Minimize an FST in-place\n    Params:\n      fst: Fst\n      config: Configuration\n    Returns:\n      fst\n    \"\"\"\n    ret_code = lib.fst_minimize_with_config(fst.ptr, config.ptr)\n    err_msg = \"Error while minimizing FST\"\n    check_ffi_error(ret_code, err_msg)\n\n    return fst\n</code></pre>"},{"location":"rustfst/algorithms/#rustfst.algorithms.optimize","title":"<code>optimize</code>","text":""},{"location":"rustfst/algorithms/#rustfst.algorithms.optimize-classes","title":"Classes","text":""},{"location":"rustfst/algorithms/#rustfst.algorithms.optimize-functions","title":"Functions","text":""},{"location":"rustfst/algorithms/#rustfst.algorithms.optimize.optimize","title":"<code>optimize(fst: VectorFst) -&gt; VectorFst</code>","text":"<p>Optimize an fst in-place Args:     fst: Fst to optimize.</p> Source code in <code>rustfst/algorithms/optimize.py</code> <pre><code>def optimize(fst: VectorFst) -&gt; VectorFst:\n    \"\"\"\n    Optimize an fst in-place\n    Args:\n        fst: Fst to optimize.\n    \"\"\"\n    ret_code = lib.fst_optimize(fst.ptr)\n    err_msg = \"Error during optimize\"\n    check_ffi_error(ret_code, err_msg)\n    return fst\n</code></pre>"},{"location":"rustfst/algorithms/#rustfst.algorithms.optimize.optimize_in_log","title":"<code>optimize_in_log(fst: VectorFst) -&gt; VectorFst</code>","text":"<p>Optimize an fst in-place in the log semiring. Args:     fst: Fst to optimize.</p> Source code in <code>rustfst/algorithms/optimize.py</code> <pre><code>def optimize_in_log(fst: VectorFst) -&gt; VectorFst:\n    \"\"\"\n    Optimize an fst in-place in the log semiring.\n    Args:\n        fst: Fst to optimize.\n    \"\"\"\n    ret_code = lib.fst_optimize_in_log(ctypes.byref(fst.ptr))\n    err_msg = \"Error during optimize_in_log\"\n    check_ffi_error(ret_code, err_msg)\n    return fst\n</code></pre>"},{"location":"rustfst/algorithms/#rustfst.algorithms.project","title":"<code>project</code>","text":""},{"location":"rustfst/algorithms/#rustfst.algorithms.project-classes","title":"Classes","text":""},{"location":"rustfst/algorithms/#rustfst.algorithms.project.ProjectType","title":"<code>ProjectType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Different types of labels projection in a Fst.</p> Source code in <code>rustfst/algorithms/project.py</code> <pre><code>class ProjectType(Enum):\n    \"\"\"\n    Different types of labels projection in a Fst.\n    \"\"\"\n\n    PROJECT_INPUT = 0\n    \"\"\"\n    Input projection : output labels are replaced with input ones.\n    \"\"\"\n    PROJECT_OUTPUT = 1\n    \"\"\"\n    Output projection : input labels are replaced with output ones.\n    \"\"\"\n</code></pre> Attributes <code>PROJECT_INPUT = 0</code> <code>class-attribute</code> <code>instance-attribute</code> <p>Input projection : output labels are replaced with input ones.</p> <code>PROJECT_OUTPUT = 1</code> <code>class-attribute</code> <code>instance-attribute</code> <p>Output projection : input labels are replaced with output ones.</p>"},{"location":"rustfst/algorithms/#rustfst.algorithms.project-functions","title":"Functions","text":""},{"location":"rustfst/algorithms/#rustfst.algorithms.project.project","title":"<code>project(fst: VectorFst, proj_type: ProjectType) -&gt; VectorFst</code>","text":"<p>Convert a Fst to an acceptor using input or output labels. Args:     fst: Fst on which to apply the algorithm.     proj_type: Whether to replace input labels or output labels. Returns:     The resulting Fst.</p> Source code in <code>rustfst/algorithms/project.py</code> <pre><code>def project(fst: VectorFst, proj_type: ProjectType) -&gt; VectorFst:\n    \"\"\"\n    Convert a Fst to an acceptor using input or output labels.\n    Args:\n        fst: Fst on which to apply the algorithm.\n        proj_type: Whether to replace input labels or output labels.\n    Returns:\n        The resulting Fst.\n    \"\"\"\n    config = ctypes.pointer(ctypes.c_void_p())\n    ret_code = lib.fst_project_type_new(\n        ctypes.c_size_t(proj_type.value),\n        ctypes.byref(config),\n    )\n    err_msg = \"Error creating ProjectType\"\n    check_ffi_error(ret_code, err_msg)\n\n    ret_code = lib.fst_project(fst.ptr, config)\n    err_msg = \"Error during projection\"\n    check_ffi_error(ret_code, err_msg)\n\n    return fst\n</code></pre>"},{"location":"rustfst/algorithms/#rustfst.algorithms.randgen","title":"<code>randgen</code>","text":""},{"location":"rustfst/algorithms/#rustfst.algorithms.randgen-classes","title":"Classes","text":""},{"location":"rustfst/algorithms/#rustfst.algorithms.randgen-functions","title":"Functions","text":""},{"location":"rustfst/algorithms/#rustfst.algorithms.randgen.randgen","title":"<code>randgen(ifst: Fst, npath: int = 1, seed: int = 0, select: str = 'uniform', max_length: int = 2147483647, weight: bool = False, remove_total_weight: bool = False) -&gt; VectorFst</code>","text":"<p>Randomly generate successful paths in an FST. This operation randomly generates a set of successful paths in the input FST. This relies on a mechanism for selecting arcs, specified using the <code>select</code> argument. The default selector, \"uniform\", randomly selects a transition using a uniform distribution. The \"log_prob\" selector randomly selects a transition w.r.t. the weights treated as negative log probabilities after normalizing for the total weight leaving the state. In all cases, finality is treated as a transition to a super-final state.</p> <p>Parameters:</p> Name Type Description Default <code>ifst</code> <code>Fst</code> <p>The input FST.</p> required <code>npath</code> <code>int</code> <p>The number of random paths to generate.</p> <code>1</code> <code>seed</code> <code>int</code> <p>An optional seed value for random path generation; if zero, the current time and process ID is used.</p> <code>0</code> <code>select</code> <code>str</code> <p>A string matching a known random arc selection type; one of: \"uniform\", \"log_prob\", \"fast_log_prob\".</p> <code>'uniform'</code> <code>max_length</code> <code>int</code> <p>The maximum length of each random path.</p> <code>2147483647</code> <code>weight</code> <code>bool</code> <p>Should the output be weighted by path count?</p> <code>False</code> <code>remove_total_weight</code> <code>bool</code> <p>Should the total weight be removed (ignored when <code>weighted</code> is False)?</p> <code>False</code> <p>Returns:</p> Type Description <code>VectorFst</code> <p>An FST containing one or more random paths.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>when something wrong happened.</p> Source code in <code>rustfst/algorithms/randgen.py</code> <pre><code>def randgen(\n    ifst: Fst,\n    npath: int = 1,\n    seed: int = 0,\n    select: str = \"uniform\",\n    max_length: int = 2147483647,\n    weight: bool = False,\n    remove_total_weight: bool = False,\n) -&gt; VectorFst:\n    \"\"\"\n    Randomly generate successful paths in an FST.\n    This operation randomly generates a set of successful paths in the input FST.\n    This relies on a mechanism for selecting arcs, specified using the `select`\n    argument. The default selector, \"uniform\", randomly selects a transition\n    using a uniform distribution. The \"log_prob\" selector randomly selects a\n    transition w.r.t. the weights treated as negative log probabilities after\n    normalizing for the total weight leaving the state. In all cases, finality is\n    treated as a transition to a super-final state.\n\n    Args:\n        ifst: The input FST.\n        npath: The number of random paths to generate.\n        seed: An optional seed value for random path generation; if zero, the\n            current time and process ID is used.\n        select: A string matching a known random arc selection type; one of:\n            \"uniform\", \"log_prob\", \"fast_log_prob\".\n        max_length: The maximum length of each random path.\n        weight: Should the output be weighted by path count?\n        remove_total_weight: Should the total weight be removed (ignored when\n            `weighted` is False)?\n\n    Returns:\n        An FST containing one or more random paths.\n\n    Raises:\n      ValueError: when something wrong happened.\n    \"\"\"\n\n    if select != \"uniform\":\n        raise ValueError(\n            f\"Only the uniform distribution is supported for now. Found {select}\"\n        )\n\n    npath = ctypes.c_size_t(npath)\n    seed = ctypes.c_size_t(seed)\n    max_length = ctypes.c_size_t(max_length)\n    weight = ctypes.c_bool(weight)\n    remove_total_weight = ctypes.c_bool(remove_total_weight)\n    randgen_fst = ctypes.pointer(ctypes.c_void_p())\n\n    ret_code = lib.fst_randgen(\n        ifst.ptr,\n        npath,\n        seed,\n        max_length,\n        weight,\n        remove_total_weight,\n        ctypes.byref(randgen_fst),\n    )\n    err_msg = \"Error during randgen\"\n    check_ffi_error(ret_code, err_msg)\n\n    return VectorFst(ptr=randgen_fst)\n</code></pre>"},{"location":"rustfst/algorithms/#rustfst.algorithms.replace","title":"<code>replace</code>","text":""},{"location":"rustfst/algorithms/#rustfst.algorithms.replace-classes","title":"Classes","text":""},{"location":"rustfst/algorithms/#rustfst.algorithms.replace-functions","title":"Functions","text":""},{"location":"rustfst/algorithms/#rustfst.algorithms.replace.replace","title":"<code>replace(root_idx: int, fst_list: List[Tuple[int, VectorFst]], epsilon_on_replace: bool) -&gt; VectorFst</code>","text":"<p>Recursively replaces trs in the root FSTs with other FSTs.</p> <p>Replace supports replacement of trs in one Fst with another FST. This replacement is recursive. Replace takes an array of FST(s). One FST represents the root (or topology) machine. The root FST refers to other FSTs by recursively replacing trs labeled as non-terminals with the matching non-terminal FST. Currently Replace uses the output symbols of the trs to determine whether the transition is a non-terminal transition or not. A non-terminal can be any label that is not a non-zero terminal label in the output alphabet.</p> <p>Note that input argument is a vector of pairs. These correspond to the tuple of non-terminal Label and corresponding FST.</p> <p>Examples:</p> <ul> <li>Root Fst :</li> </ul> <p></p> <ul> <li>Fst for non-terminal #NAME :</li> </ul> <p></p> <ul> <li>Fst for non-terminal #FIRSTNAME :</li> </ul> <p></p> <ul> <li>Fst for non-terminal #LASTNAME :</li> </ul> <p></p> <ul> <li>Output :</li> </ul> <p></p> <p>Parameters:</p> Name Type Description Default <code>root_idx</code> <code>int</code> required <code>fst_list</code> <code>List[Tuple[int, VectorFst]]</code> required <code>epsilon_on_replace</code> <code>bool</code> required <p>Returns:</p> Type Description <code>VectorFst</code> <p>The resulting Fst.</p> Source code in <code>rustfst/algorithms/replace.py</code> <pre><code>def replace(\n    root_idx: int, fst_list: List[Tuple[int, VectorFst]], epsilon_on_replace: bool\n) -&gt; VectorFst:\n    \"\"\"\n    Recursively replaces trs in the root FSTs with other FSTs.\n\n    Replace supports replacement of trs in one Fst with another FST. This\n    replacement is recursive. Replace takes an array of FST(s). One FST\n    represents the root (or topology) machine. The root FST refers to other FSTs\n    by recursively replacing trs labeled as non-terminals with the matching\n    non-terminal FST. Currently Replace uses the output symbols of the trs to\n    determine whether the transition is a non-terminal transition or not. A non-terminal can be\n    any label that is not a non-zero terminal label in the output alphabet.\n\n    Note that input argument is a vector of pairs. These correspond to the tuple\n    of non-terminal Label and corresponding FST.\n\n    Examples:\n\n    - Root Fst :\n\n    ![replace_in_1](https://raw.githubusercontent.com/Garvys/rustfst-images-doc/master/images/replace_in_1.svg?sanitize=true)\n\n    - Fst for non-terminal #NAME :\n\n    ![replace_in_2](https://raw.githubusercontent.com/Garvys/rustfst-images-doc/master/images/replace_in_2.svg?sanitize=true)\n\n    - Fst for non-terminal #FIRSTNAME :\n\n    ![replace_in_3](https://raw.githubusercontent.com/Garvys/rustfst-images-doc/master/images/replace_in_3.svg?sanitize=true)\n\n    - Fst for non-terminal #LASTNAME :\n\n    ![replace_in_4](https://raw.githubusercontent.com/Garvys/rustfst-images-doc/master/images/replace_in_4.svg?sanitize=true)\n\n    - Output :\n\n    ![replace_out](https://raw.githubusercontent.com/Garvys/rustfst-images-doc/master/images/replace_out.svg?sanitize=true)\n\n    Args:\n        root_idx:\n        fst_list:\n        epsilon_on_replace:\n\n    Returns:\n        The resulting Fst.\n\n    \"\"\"\n    pairs = [LabelFstPair(label, fst.ptr) for (label, fst) in fst_list]\n    pairs_array = (LabelFstPair * len(pairs))(*pairs)\n    res_fst = ctypes.pointer(ctypes.c_void_p())\n    ret_code = lib.fst_replace(\n        ctypes.c_size_t(root_idx),\n        ctypes.byref(pairs_array),\n        ctypes.c_size_t(len(pairs)),\n        ctypes.c_bool(epsilon_on_replace),\n        ctypes.byref(res_fst),\n    )\n    err_msg = \"Error performing replace\"\n    check_ffi_error(ret_code, err_msg)\n\n    return VectorFst(ptr=res_fst)\n</code></pre>"},{"location":"rustfst/algorithms/#rustfst.algorithms.reverse","title":"<code>reverse</code>","text":""},{"location":"rustfst/algorithms/#rustfst.algorithms.reverse-classes","title":"Classes","text":""},{"location":"rustfst/algorithms/#rustfst.algorithms.reverse-functions","title":"Functions","text":""},{"location":"rustfst/algorithms/#rustfst.algorithms.reverse.reverse","title":"<code>reverse(fst: VectorFst) -&gt; VectorFst</code>","text":"<p>Reverse an Fst, returning a new Fst which accepts the same language in reverse order.</p> <p>Not to be confused with <code>inverse</code>, which does something totally different! Args:   fst: Fst to reverse Returns:   Newly created, reversed Fst.</p> Source code in <code>rustfst/algorithms/reverse.py</code> <pre><code>def reverse(fst: VectorFst) -&gt; VectorFst:\n    \"\"\"\n    Reverse an Fst, returning a new Fst which accepts\n    the same language in reverse order.\n\n    Not to be confused with `inverse`, which does something\n    totally different!\n    Args:\n      fst: Fst to reverse\n    Returns:\n      Newly created, reversed Fst.\n    \"\"\"\n\n    reversed_fst = ctypes.c_void_p()\n    ret_code = lib.fst_reverse(fst.ptr, ctypes.byref(reversed_fst))\n    err_msg = \"Error during reverse\"\n    check_ffi_error(ret_code, err_msg)\n\n    return VectorFst(ptr=reversed_fst)\n</code></pre>"},{"location":"rustfst/algorithms/#rustfst.algorithms.rm_epsilon","title":"<code>rm_epsilon</code>","text":""},{"location":"rustfst/algorithms/#rustfst.algorithms.rm_epsilon-classes","title":"Classes","text":""},{"location":"rustfst/algorithms/#rustfst.algorithms.rm_epsilon-functions","title":"Functions","text":""},{"location":"rustfst/algorithms/#rustfst.algorithms.rm_epsilon.rm_epsilon","title":"<code>rm_epsilon(fst: VectorFst) -&gt; VectorFst</code>","text":"<p>Remove epsilon transitions in-place Args:   fst: Fst to remove epsilons from Returns:   fst: Same FST, modified in place</p> Source code in <code>rustfst/algorithms/rm_epsilon.py</code> <pre><code>def rm_epsilon(fst: VectorFst) -&gt; VectorFst:\n    \"\"\"\n    Remove epsilon transitions in-place\n    Args:\n      fst: Fst to remove epsilons from\n    Returns:\n      fst: Same FST, modified in place\n    \"\"\"\n\n    ret_code = lib.fst_rm_epsilon(fst.ptr)\n    err_msg = \"Error during rm_epsilon\"\n    check_ffi_error(ret_code, err_msg)\n\n    return fst\n</code></pre>"},{"location":"rustfst/algorithms/#rustfst.algorithms.shortest_path","title":"<code>shortest_path</code>","text":""},{"location":"rustfst/algorithms/#rustfst.algorithms.shortest_path-classes","title":"Classes","text":""},{"location":"rustfst/algorithms/#rustfst.algorithms.shortest_path.ShortestPathConfig","title":"<code>ShortestPathConfig</code>","text":"<p>Configuration for shortest-path operation.</p> <p>Parameters:</p> Name Type Description Default <code>nshortest</code> <code>int</code> <p>Number of shortest paths to return</p> <code>1</code> <code>unique</code> <code>bool</code> <p>Return only unique label sequences</p> <code>False</code> <code>delta</code> <code>Union[float, None]</code> <p>Difference in weights considered significant</p> <code>None</code> Source code in <code>rustfst/algorithms/shortest_path.py</code> <pre><code>class ShortestPathConfig:\n    \"\"\"\n    Configuration for shortest-path operation.\n\n    Args:\n      nshortest: Number of shortest paths to return\n      unique: Return only unique label sequences\n      delta: Difference in weights considered significant\n    \"\"\"\n\n    def __init__(\n        self, nshortest: int = 1, unique: bool = False, delta: Union[float, None] = None\n    ):\n        if delta is None:\n            delta = KSHORTESTDELTA\n        config = ctypes.pointer(ctypes.c_void_p())\n        ret_code = lib.fst_shortest_path_config_new(\n            ctypes.c_float(delta),\n            ctypes.c_size_t(nshortest),\n            ctypes.c_bool(unique),\n            ctypes.byref(config),\n        )\n        err_msg = \"Error creating ShortestPathConfig\"\n        check_ffi_error(ret_code, err_msg)\n        self.ptr = config\n</code></pre>"},{"location":"rustfst/algorithms/#rustfst.algorithms.shortest_path-functions","title":"Functions","text":""},{"location":"rustfst/algorithms/#rustfst.algorithms.shortest_path.shortestpath","title":"<code>shortestpath(fst: VectorFst) -&gt; VectorFst</code>","text":"<p>Construct a FST containing the shortest path of the input FST Args:   fst: Fst Returns:   Newly-created FST containing only the shortest path of the input FST.</p> Source code in <code>rustfst/algorithms/shortest_path.py</code> <pre><code>def shortestpath(fst: VectorFst) -&gt; VectorFst:\n    \"\"\"\n    Construct a FST containing the shortest path of the input FST\n    Args:\n      fst: Fst\n    Returns:\n      Newly-created FST containing only the shortest path of the input FST.\n    \"\"\"\n\n    shortest_path = ctypes.c_void_p()\n    ret_code = lib.fst_shortest_path(fst.ptr, ctypes.byref(shortest_path))\n    err_msg = \"Error computing shortest path\"\n    check_ffi_error(ret_code, err_msg)\n\n    return VectorFst(ptr=shortest_path)\n</code></pre>"},{"location":"rustfst/algorithms/#rustfst.algorithms.shortest_path.shortestpath_with_config","title":"<code>shortestpath_with_config(fst: VectorFst, config: ShortestPathConfig) -&gt; VectorFst</code>","text":"<p>Construct a FST containing the shortest path of the input FST Args:   fst: Fst   config: Configuration for shortest-path operation. Returns:   Newly-created FST containing only the shortest path of the input FST.</p> Source code in <code>rustfst/algorithms/shortest_path.py</code> <pre><code>def shortestpath_with_config(fst: VectorFst, config: ShortestPathConfig) -&gt; VectorFst:\n    \"\"\"\n    Construct a FST containing the shortest path of the input FST\n    Args:\n      fst: Fst\n      config: Configuration for shortest-path operation.\n    Returns:\n      Newly-created FST containing only the shortest path of the input FST.\n    \"\"\"\n\n    shortest_path = ctypes.c_void_p()\n\n    ret_code = lib.fst_shortest_path_with_config(\n        fst.ptr, config.ptr, ctypes.byref(shortest_path)\n    )\n    err_msg = \"Error computing shortest path\"\n    check_ffi_error(ret_code, err_msg)\n\n    return VectorFst(ptr=shortest_path)\n</code></pre>"},{"location":"rustfst/algorithms/#rustfst.algorithms.top_sort","title":"<code>top_sort</code>","text":""},{"location":"rustfst/algorithms/#rustfst.algorithms.top_sort-classes","title":"Classes","text":""},{"location":"rustfst/algorithms/#rustfst.algorithms.top_sort-functions","title":"Functions","text":""},{"location":"rustfst/algorithms/#rustfst.algorithms.top_sort.top_sort","title":"<code>top_sort(fst: VectorFst) -&gt; VectorFst</code>","text":"<p>This operation topologically sorts its input. When sorted, all transitions are from lower to higher state IDs.</p> <p>Examples :</p> <ul> <li>Input</li> </ul> <p></p> <ul> <li>Output</li> </ul> <p></p> <p>Parameters:</p> Name Type Description Default <code>fst</code> <code>VectorFst</code> <p>Fst to top_sort.</p> required <p>Returns:     Equivalent top sorted Fst. Modification also happens in-place.</p> Source code in <code>rustfst/algorithms/top_sort.py</code> <pre><code>def top_sort(fst: VectorFst) -&gt; VectorFst:\n    \"\"\"\n    This operation topologically sorts its input. When sorted, all transitions are from lower to higher state IDs.\n\n    Examples :\n\n    - Input\n\n    ![topsort_in](https://raw.githubusercontent.com/Garvys/rustfst-images-doc/master/images/topsort_in.svg?sanitize=true)\n\n    - Output\n\n    ![topsort_out](https://raw.githubusercontent.com/Garvys/rustfst-images-doc/master/images/topsort_out.svg?sanitize=true)\n\n    Args:\n        fst: Fst to top_sort.\n    Returns:\n        Equivalent top sorted Fst. Modification also happens in-place.\n    \"\"\"\n\n    top_sorted_fst = ctypes.c_void_p()\n    ret_code = lib.fst_top_sort(fst.ptr, ctypes.byref(top_sorted_fst))\n    err_msg = \"Error during top_sort\"\n    check_ffi_error(ret_code, err_msg)\n\n    return VectorFst(ptr=top_sorted_fst)\n</code></pre>"},{"location":"rustfst/algorithms/#rustfst.algorithms.tr_sort","title":"<code>tr_sort</code>","text":""},{"location":"rustfst/algorithms/#rustfst.algorithms.tr_sort-classes","title":"Classes","text":""},{"location":"rustfst/algorithms/#rustfst.algorithms.tr_sort-functions","title":"Functions","text":""},{"location":"rustfst/algorithms/#rustfst.algorithms.tr_sort.tr_sort","title":"<code>tr_sort(fst: VectorFst, ilabel_cmp: bool) -&gt; VectorFst</code>","text":"<p>Sort fst trs in place according to their input or output label. output label.</p> <p>This is often necessary for composition to work properly.  It corresponds to <code>ArcSort</code> in OpenFST.</p> <p>Parameters:</p> Name Type Description Default <code>fst</code> <code>VectorFst</code> <p>FST to be tr-sorted in-place.</p> required <code>ilabel_cmp</code> <code>bool</code> <p>Sort on input labels if <code>True</code>, output labels          if <code>False</code>.</p> required <p>Returns:   fst: Same FST that was modified in-place.</p> Source code in <code>rustfst/algorithms/tr_sort.py</code> <pre><code>def tr_sort(fst: VectorFst, ilabel_cmp: bool) -&gt; VectorFst:\n    \"\"\"Sort fst trs in place according to their input or output label.\n    output label.\n\n    This is often necessary for composition to work properly.  It\n    corresponds to `ArcSort` in OpenFST.\n\n    Args:\n      fst: FST to be tr-sorted in-place.\n      ilabel_cmp: Sort on input labels if `True`, output labels\n                 if `False`.\n    Returns:\n      fst: Same FST that was modified in-place.\n    \"\"\"\n\n    ret_code = lib.fst_tr_sort(fst.ptr, ctypes.c_bool(ilabel_cmp))\n    err_msg = \"Error during tr_sort\"\n    check_ffi_error(ret_code, err_msg)\n    return fst\n</code></pre>"},{"location":"rustfst/algorithms/#rustfst.algorithms.tr_unique","title":"<code>tr_unique</code>","text":""},{"location":"rustfst/algorithms/#rustfst.algorithms.tr_unique-classes","title":"Classes","text":""},{"location":"rustfst/algorithms/#rustfst.algorithms.tr_unique-functions","title":"Functions","text":""},{"location":"rustfst/algorithms/#rustfst.algorithms.tr_unique.tr_unique","title":"<code>tr_unique(fst: VectorFst) -&gt; VectorFst</code>","text":"<p>Modify an FST in-place, keeping a single instance of trs leaving the same state, going to the same state and with the same input labels, output labels and weight.</p> <p>Parameters:</p> Name Type Description Default <code>fst</code> <code>VectorFst</code> <p>Fst to modify</p> required <p>Returns:     fst: Same FST, modified in-place</p> Source code in <code>rustfst/algorithms/tr_unique.py</code> <pre><code>def tr_unique(fst: VectorFst) -&gt; VectorFst:\n    \"\"\"\n    Modify an FST in-place, keeping a single instance of trs\n    leaving the same state, going to the same state and with the same\n    input labels, output labels and weight.\n\n    Args:\n        fst: Fst to modify\n    Returns:\n        fst: Same FST, modified in-place\n    \"\"\"\n\n    ret_code = lib.fst_tr_unique(fst.ptr)\n    err_msg = \"Error during tr_unique\"\n    check_ffi_error(ret_code, err_msg)\n    return fst\n</code></pre>"},{"location":"rustfst/algorithms/#rustfst.algorithms.union","title":"<code>union</code>","text":""},{"location":"rustfst/algorithms/#rustfst.algorithms.union-classes","title":"Classes","text":""},{"location":"rustfst/algorithms/#rustfst.algorithms.union-functions","title":"Functions","text":""},{"location":"rustfst/algorithms/#rustfst.algorithms.union.union","title":"<code>union(fst: VectorFst, other_fst: VectorFst) -&gt; VectorFst</code>","text":"<p>Performs the union of two wFSTs. If A transduces string <code>x</code> to <code>y</code> with weight <code>a</code> and <code>B</code> transduces string <code>w</code> to <code>v</code> with weight <code>b</code>, then their union transduces <code>x</code> to <code>y</code> with weight <code>a</code> and <code>w</code> to <code>v</code> with weight <code>b</code>.</p> <p>Examples: - Input Fst 1:</p> <p></p> <ul> <li>Input Fst 2:</li> </ul> <p></p> <ul> <li>Union:</li> </ul> <p></p> <p>Parameters:</p> Name Type Description Default <code>fst</code> <code>VectorFst</code> required <code>other_fst</code> <code>VectorFst</code> required <p>Returns:      The resulting Fst.</p> Source code in <code>rustfst/algorithms/union.py</code> <pre><code>def union(fst: VectorFst, other_fst: VectorFst) -&gt; VectorFst:\n    \"\"\"\n    Performs the union of two wFSTs. If A transduces string `x` to `y` with weight `a`\n    and `B` transduces string `w` to `v` with weight `b`, then their union transduces `x` to `y`\n    with weight `a` and `w` to `v` with weight `b`.\n\n    Examples:\n    - Input Fst 1:\n\n    ![union_in_1](https://raw.githubusercontent.com/Garvys/rustfst-images-doc/master/images/union_in_1.svg?sanitize=true)\n\n    - Input Fst 2:\n\n    ![union_in_2](https://raw.githubusercontent.com/Garvys/rustfst-images-doc/master/images/union_in_2.svg?sanitize=true)\n\n    - Union:\n\n    ![union_out](https://raw.githubusercontent.com/Garvys/rustfst-images-doc/master/images/union_out.svg?sanitize=true)\n\n    Args:\n        fst:\n        other_fst:\n    Returns:\n         The resulting Fst.\n\n    \"\"\"\n\n    ret_code = lib.fst_union(fst.ptr, other_fst.ptr)\n    err_msg = \"Error during union\"\n    check_ffi_error(ret_code, err_msg)\n\n    return fst\n</code></pre>"},{"location":"rustfst/algorithms/#rustfst.algorithms.union.union_list","title":"<code>union_list(fsts: List[VectorFst]) -&gt; VectorFst</code>","text":"<p>Computes the union of a list of Fsts.</p> <p>Parameters:</p> Name Type Description Default <code>fsts</code> <code>List[VectorFst]</code> <p>The list of Fsts to produce the union.</p> required <p>Returns:</p> Type Description <code>VectorFst</code> <p>The resulting Fst.</p> Source code in <code>rustfst/algorithms/union.py</code> <pre><code>def union_list(fsts: List[VectorFst]) -&gt; VectorFst:\n    \"\"\"\n    Computes the union of a list of Fsts.\n\n    Args:\n        fsts: The list of Fsts to produce the union.\n\n    Returns:\n        The resulting Fst.\n\n    \"\"\"\n    if not fsts:\n        raise ValueError(\"fsts must be at least of len 1\")\n    fsts = [f.copy() for f in fsts]\n    res_fst = fsts[0]\n    for f in fsts[1:]:\n        res_fst = union(res_fst, f)\n    return res_fst\n</code></pre>"},{"location":"rustfst/algorithms/compose/","title":"compose","text":""},{"location":"rustfst/algorithms/compose/#rustfst.algorithms.compose-classes","title":"Classes","text":""},{"location":"rustfst/algorithms/compose/#rustfst.algorithms.compose.ComposeConfig","title":"<code>ComposeConfig</code>","text":"<p>Configuration for compose operation.</p> <p>Parameters:</p> Name Type Description Default <code>compose_filter</code> <code>ComposeFilter</code> <p>Filter which determines allowable matches during               composition operation.</p> <code>AUTOFILTER</code> <code>connect</code> <code>bool</code> <p>Connect the resulting FST after composition.</p> <code>True</code> <code>matcher1_config</code> <code>Optional[MatcherConfig]</code> <p>Matcher configuration for left-hand FST.</p> <code>None</code> <code>matcher2_config</code> <code>Optional[MatcherConfig]</code> <p>Matcher configuration for right-hand FST.</p> <code>None</code> Source code in <code>rustfst/algorithms/compose.py</code> <pre><code>class ComposeConfig:\n    \"\"\"\n    Configuration for compose operation.\n\n    Args:\n      compose_filter: Filter which determines allowable matches during\n                      composition operation.\n      connect: Connect the resulting FST after composition.\n      matcher1_config: Matcher configuration for left-hand FST.\n      matcher2_config: Matcher configuration for right-hand FST.\n    \"\"\"\n\n    def __init__(\n        self,\n        compose_filter: ComposeFilter = ComposeFilter.AUTOFILTER,\n        connect: bool = True,\n        matcher1_config: Optional[MatcherConfig] = None,\n        matcher2_config: Optional[MatcherConfig] = None,\n    ):\n        config = ctypes.pointer(ctypes.c_void_p())\n\n        m1_ptr = None\n        if matcher1_config is not None:\n            m1_ptr = matcher1_config.ptr\n        m2_ptr = None\n\n        if matcher2_config is not None:\n            m2_ptr = matcher2_config.ptr\n\n        ret_code = lib.fst_compose_config_new(\n            ctypes.c_size_t(compose_filter.value),\n            ctypes.c_bool(connect),\n            m1_ptr,\n            m2_ptr,\n            ctypes.byref(config),\n        )\n        err_msg = \"Error creating ComposeConfig\"\n        check_ffi_error(ret_code, err_msg)\n        self.ptr = config\n\n    def __del__(self):\n        lib.fst_compose_config_destroy(self.ptr)\n</code></pre>"},{"location":"rustfst/algorithms/compose/#rustfst.algorithms.compose-functions","title":"Functions","text":""},{"location":"rustfst/algorithms/compose/#rustfst.algorithms.compose.compose","title":"<code>compose(fst: VectorFst, other_fst: VectorFst) -&gt; VectorFst</code>","text":"<p>Compute the composition of two FSTs. Args:     fst: Left fst.     other_fst: Right fst. Returns:     Resulting fst.</p> Source code in <code>rustfst/algorithms/compose.py</code> <pre><code>def compose(fst: VectorFst, other_fst: VectorFst) -&gt; VectorFst:\n    \"\"\"\n    Compute the composition of two FSTs.\n    Args:\n        fst: Left fst.\n        other_fst: Right fst.\n    Returns:\n        Resulting fst.\n    \"\"\"\n\n    composition = ctypes.pointer(ctypes.c_void_p())\n    ret_code = lib.fst_compose(fst.ptr, other_fst.ptr, ctypes.byref(composition))\n    err_msg = \"Error Composing FSTs\"\n    check_ffi_error(ret_code, err_msg)\n\n    return VectorFst(ptr=composition)\n</code></pre>"},{"location":"rustfst/algorithms/compose/#rustfst.algorithms.compose.compose_with_config","title":"<code>compose_with_config(fst: VectorFst, other_fst: VectorFst, config: ComposeConfig) -&gt; VectorFst</code>","text":"<p>Compute the composition of two FSTs parametrized with a config. Args:     fst: Left fst.     other_fst: Right fst.     config: Config parameters of the composition. Returns:     Resulting fst.</p> Source code in <code>rustfst/algorithms/compose.py</code> <pre><code>def compose_with_config(\n    fst: VectorFst, other_fst: VectorFst, config: ComposeConfig\n) -&gt; VectorFst:\n    \"\"\"\n    Compute the composition of two FSTs parametrized with a config.\n    Args:\n        fst: Left fst.\n        other_fst: Right fst.\n        config: Config parameters of the composition.\n    Returns:\n        Resulting fst.\n    \"\"\"\n\n    composition = ctypes.pointer(ctypes.c_void_p())\n    ret_code = lib.fst_compose_with_config(\n        fst.ptr, other_fst.ptr, config.ptr, ctypes.byref(composition)\n    )\n    err_msg = \"Error Composing FSTs\"\n    check_ffi_error(ret_code, err_msg)\n\n    return VectorFst(ptr=composition)\n</code></pre>"},{"location":"rustfst/algorithms/concat/","title":"concat","text":""},{"location":"rustfst/algorithms/concat/#rustfst.algorithms.concat-classes","title":"Classes","text":""},{"location":"rustfst/algorithms/concat/#rustfst.algorithms.concat-functions","title":"Functions","text":""},{"location":"rustfst/algorithms/concat/#rustfst.algorithms.concat.concat","title":"<code>concat(fst: VectorFst, other_fst: VectorFst) -&gt; VectorFst</code>","text":"<p>Compute the concatenation of two Fsts. Args:     fst: Left fst.     other_fst: Right fst. Returns:     Resulting fst.</p> Source code in <code>rustfst/algorithms/concat.py</code> <pre><code>def concat(fst: VectorFst, other_fst: VectorFst) -&gt; VectorFst:\n    \"\"\"\n    Compute the concatenation of two Fsts.\n    Args:\n        fst: Left fst.\n        other_fst: Right fst.\n    Returns:\n        Resulting fst.\n    \"\"\"\n\n    ret_code = lib.fst_concat(fst.ptr, other_fst.ptr)\n    err_msg = \"Error during concat\"\n    check_ffi_error(ret_code, err_msg)\n\n    return fst\n</code></pre>"},{"location":"rustfst/algorithms/concat/#rustfst.algorithms.concat.concat_list","title":"<code>concat_list(fsts: List[VectorFst]) -&gt; VectorFst</code>","text":"<p>Compute the concatenation of a list of Fsts. Args:     fsts: List of Fsts to concatenated</p> <p>Returns:</p> Type Description <code>VectorFst</code> <p>The resulting concatenated Fst.</p> Source code in <code>rustfst/algorithms/concat.py</code> <pre><code>def concat_list(fsts: List[VectorFst]) -&gt; VectorFst:\n    \"\"\"\n    Compute the concatenation of a list of Fsts.\n    Args:\n        fsts: List of Fsts to concatenated\n\n    Returns:\n        The resulting concatenated Fst.\n    \"\"\"\n    if not fsts:\n        raise ValueError(\"fsts must be at least of len 1\")\n    fsts = [f.copy() for f in fsts]\n    concatenated = fsts[0]\n    for f in fsts[1:]:\n        concatenated = concatenated.concat(f)\n    return concatenated\n</code></pre>"},{"location":"rustfst/algorithms/connect/","title":"connect","text":""},{"location":"rustfst/algorithms/connect/#rustfst.algorithms.connect-classes","title":"Classes","text":""},{"location":"rustfst/algorithms/connect/#rustfst.algorithms.connect-functions","title":"Functions","text":""},{"location":"rustfst/algorithms/connect/#rustfst.algorithms.connect.connect","title":"<code>connect(fst: VectorFst) -&gt; VectorFst</code>","text":"<p>This operation trims an Fst in-place, removing states and trs that are not on successful paths.</p> <p>Examples :</p> <ul> <li>Input :</li> </ul> <p></p> <ul> <li>Output :</li> </ul> <p></p> Returns <p>fst</p> Source code in <code>rustfst/algorithms/connect.py</code> <pre><code>def connect(fst: VectorFst) -&gt; VectorFst:\n    \"\"\"\n    This operation trims an Fst in-place, removing states and trs that are not on\n    successful paths.\n\n    Examples :\n\n    - Input :\n\n    ![connect_in](https://raw.githubusercontent.com/Garvys/rustfst-images-doc/master/images/connect_in.svg?sanitize=true)\n\n    - Output :\n\n    ![connect_out](https://raw.githubusercontent.com/Garvys/rustfst-images-doc/master/images/connect_out.svg?sanitize=true)\n\n    Returns :\n        fst\n    \"\"\"\n\n    ret_code = lib.fst_connect(fst.ptr)\n    err_msg = \"Error during connect\"\n    check_ffi_error(ret_code, err_msg)\n\n    return fst\n</code></pre>"},{"location":"rustfst/algorithms/determinize/","title":"determinize","text":""},{"location":"rustfst/algorithms/determinize/#rustfst.algorithms.determinize-classes","title":"Classes","text":""},{"location":"rustfst/algorithms/determinize/#rustfst.algorithms.determinize.DeterminizeType","title":"<code>DeterminizeType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enumeration defining the type of the determinization to perform.</p> Source code in <code>rustfst/algorithms/determinize.py</code> <pre><code>class DeterminizeType(Enum):\n    \"\"\"\n    Enumeration defining the type of the determinization to perform.\n    \"\"\"\n\n    DETERMINIZE_FUNCTIONAL = 0\n    \"\"\"\n    Input transducer is known to be functional (or error).\n    \"\"\"\n    DETERMINIZE_NON_FUNCTIONAL = 1\n    \"\"\"\n    Input transducer is NOT known to be functional.\n    \"\"\"\n    DETERMINIZE_DISAMBIGUATE = 2\n    \"\"\"\n    Input transducer is not known to be functional but only keep the min of\n    of ambiguous outputs.\n    \"\"\"\n</code></pre>"},{"location":"rustfst/algorithms/determinize/#rustfst.algorithms.determinize.DeterminizeType-attributes","title":"Attributes","text":""},{"location":"rustfst/algorithms/determinize/#rustfst.algorithms.determinize.DeterminizeType.DETERMINIZE_FUNCTIONAL","title":"<code>DETERMINIZE_FUNCTIONAL = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Input transducer is known to be functional (or error).</p>"},{"location":"rustfst/algorithms/determinize/#rustfst.algorithms.determinize.DeterminizeType.DETERMINIZE_NON_FUNCTIONAL","title":"<code>DETERMINIZE_NON_FUNCTIONAL = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Input transducer is NOT known to be functional.</p>"},{"location":"rustfst/algorithms/determinize/#rustfst.algorithms.determinize.DeterminizeType.DETERMINIZE_DISAMBIGUATE","title":"<code>DETERMINIZE_DISAMBIGUATE = 2</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Input transducer is not known to be functional but only keep the min of of ambiguous outputs.</p>"},{"location":"rustfst/algorithms/determinize/#rustfst.algorithms.determinize.DeterminizeConfig","title":"<code>DeterminizeConfig</code>","text":"<p>Struct containing the parameters controlling the determinization algorithm.</p> Source code in <code>rustfst/algorithms/determinize.py</code> <pre><code>class DeterminizeConfig:\n    \"\"\"\n    Struct containing the parameters controlling the determinization algorithm.\n    \"\"\"\n\n    def __init__(self, det_type: DeterminizeType, delta: Optional[float] = None):\n        \"\"\"\n        Creates the configuration object.\n        Args:\n            det_type: Type of determinization to perform.\n            delta:\n        \"\"\"\n        if delta is None:\n            delta = KDELTA\n\n        config = ctypes.pointer(ctypes.c_void_p())\n        ret_code = lib.fst_determinize_config_new(\n            ctypes.c_float(delta),\n            ctypes.c_size_t(det_type.value),\n            ctypes.byref(config),\n        )\n        err_msg = \"Error creating DeterminizeConfig\"\n        check_ffi_error(ret_code, err_msg)\n        self.ptr = config\n</code></pre>"},{"location":"rustfst/algorithms/determinize/#rustfst.algorithms.determinize.DeterminizeConfig-functions","title":"Functions","text":""},{"location":"rustfst/algorithms/determinize/#rustfst.algorithms.determinize.DeterminizeConfig.__init__","title":"<code>__init__(det_type: DeterminizeType, delta: Optional[float] = None)</code>","text":"<p>Creates the configuration object. Args:     det_type: Type of determinization to perform.     delta:</p> Source code in <code>rustfst/algorithms/determinize.py</code> <pre><code>def __init__(self, det_type: DeterminizeType, delta: Optional[float] = None):\n    \"\"\"\n    Creates the configuration object.\n    Args:\n        det_type: Type of determinization to perform.\n        delta:\n    \"\"\"\n    if delta is None:\n        delta = KDELTA\n\n    config = ctypes.pointer(ctypes.c_void_p())\n    ret_code = lib.fst_determinize_config_new(\n        ctypes.c_float(delta),\n        ctypes.c_size_t(det_type.value),\n        ctypes.byref(config),\n    )\n    err_msg = \"Error creating DeterminizeConfig\"\n    check_ffi_error(ret_code, err_msg)\n    self.ptr = config\n</code></pre>"},{"location":"rustfst/algorithms/determinize/#rustfst.algorithms.determinize-functions","title":"Functions","text":""},{"location":"rustfst/algorithms/determinize/#rustfst.algorithms.determinize.determinize","title":"<code>determinize(fst: VectorFst) -&gt; VectorFst</code>","text":"<p>Make an Fst deterministic Args:     fst: The Fst to make deterministic. Returns:     The resulting Fst.</p> Source code in <code>rustfst/algorithms/determinize.py</code> <pre><code>def determinize(fst: VectorFst) -&gt; VectorFst:\n    \"\"\"\n    Make an Fst deterministic\n    Args:\n        fst: The Fst to make deterministic.\n    Returns:\n        The resulting Fst.\n    \"\"\"\n    det_fst = ctypes.pointer(ctypes.c_void_p())\n    ret_code = lib.fst_determinize(fst.ptr, ctypes.byref(det_fst))\n    err_msg = \"Error during determinization\"\n    check_ffi_error(ret_code, err_msg)\n\n    return VectorFst(ptr=det_fst)\n</code></pre>"},{"location":"rustfst/algorithms/determinize/#rustfst.algorithms.determinize.determinize_with_config","title":"<code>determinize_with_config(fst: VectorFst, config: DeterminizeConfig) -&gt; VectorFst</code>","text":"<p>Make an Fst deterministic Args:     fst: The Fst to make deterministic.     config: Configuration of the determinization algorithm to use. Returns:     The resulting Fst.</p> Source code in <code>rustfst/algorithms/determinize.py</code> <pre><code>def determinize_with_config(fst: VectorFst, config: DeterminizeConfig) -&gt; VectorFst:\n    \"\"\"\n    Make an Fst deterministic\n    Args:\n        fst: The Fst to make deterministic.\n        config: Configuration of the determinization algorithm to use.\n    Returns:\n        The resulting Fst.\n    \"\"\"\n    det_fst = ctypes.pointer(ctypes.c_void_p())\n    ret_code = lib.fst_determinize_with_config(\n        fst.ptr, config.ptr, ctypes.byref(det_fst)\n    )\n    err_msg = \"Error during determinization\"\n    check_ffi_error(ret_code, err_msg)\n\n    return VectorFst(ptr=det_fst)\n</code></pre>"},{"location":"rustfst/algorithms/inversion/","title":"inversion","text":""},{"location":"rustfst/algorithms/inversion/#rustfst.algorithms.inversion-classes","title":"Classes","text":""},{"location":"rustfst/algorithms/inversion/#rustfst.algorithms.inversion-functions","title":"Functions","text":""},{"location":"rustfst/algorithms/inversion/#rustfst.algorithms.inversion.invert","title":"<code>invert(fst: VectorFst) -&gt; VectorFst</code>","text":"<p>Invert the transduction corresponding to an FST by exchanging the FST's input and output labels in-place.</p> <p>Parameters:</p> Name Type Description Default <code>fst</code> <code>VectorFst</code> <p>FST to be inverted.</p> required <p>Returns:    self</p> Source code in <code>rustfst/algorithms/inversion.py</code> <pre><code>def invert(fst: VectorFst) -&gt; VectorFst:\n    \"\"\"\n    Invert the transduction corresponding to an FST by exchanging the\n    FST's input and output labels in-place.\n\n    Args:\n       fst: FST to be inverted.\n    Returns:\n       self\n    \"\"\"\n\n    ret_code = lib.fst_invert(fst.ptr)\n    err_msg = \"Error during invert\"\n    check_ffi_error(ret_code, err_msg)\n\n    return fst\n</code></pre>"},{"location":"rustfst/algorithms/isomorphic/","title":"isomorphic","text":""},{"location":"rustfst/algorithms/isomorphic/#rustfst.algorithms.isomorphic-classes","title":"Classes","text":""},{"location":"rustfst/algorithms/isomorphic/#rustfst.algorithms.isomorphic-functions","title":"Functions","text":""},{"location":"rustfst/algorithms/isomorphic/#rustfst.algorithms.isomorphic.isomorphic","title":"<code>isomorphic(fst: VectorFst, other_fst: VectorFst) -&gt; bool</code>","text":"<p>Check if two Fsts are isomorphic. Args:     fst: First Fst.     other_fst: Second Fst. Returns:     Whether both Fsts are equal.</p> Source code in <code>rustfst/algorithms/isomorphic.py</code> <pre><code>def isomorphic(fst: VectorFst, other_fst: VectorFst) -&gt; bool:\n    \"\"\"\n    Check if two Fsts are isomorphic.\n    Args:\n        fst: First Fst.\n        other_fst: Second Fst.\n    Returns:\n        Whether both Fsts are equal.\n    \"\"\"\n\n    is_isomorphic = ctypes.c_size_t()\n    ret_code = lib.fst_isomorphic(fst.ptr, other_fst.ptr, ctypes.byref(is_isomorphic))\n    err_msg = \"Error checking isomorphic FSTs\"\n    check_ffi_error(ret_code, err_msg)\n\n    return bool(is_isomorphic.value)\n</code></pre>"},{"location":"rustfst/algorithms/optimize/","title":"optimize","text":""},{"location":"rustfst/algorithms/optimize/#rustfst.algorithms.optimize-classes","title":"Classes","text":""},{"location":"rustfst/algorithms/optimize/#rustfst.algorithms.optimize-functions","title":"Functions","text":""},{"location":"rustfst/algorithms/optimize/#rustfst.algorithms.optimize.optimize","title":"<code>optimize(fst: VectorFst) -&gt; VectorFst</code>","text":"<p>Optimize an fst in-place Args:     fst: Fst to optimize.</p> Source code in <code>rustfst/algorithms/optimize.py</code> <pre><code>def optimize(fst: VectorFst) -&gt; VectorFst:\n    \"\"\"\n    Optimize an fst in-place\n    Args:\n        fst: Fst to optimize.\n    \"\"\"\n    ret_code = lib.fst_optimize(fst.ptr)\n    err_msg = \"Error during optimize\"\n    check_ffi_error(ret_code, err_msg)\n    return fst\n</code></pre>"},{"location":"rustfst/algorithms/optimize/#rustfst.algorithms.optimize.optimize_in_log","title":"<code>optimize_in_log(fst: VectorFst) -&gt; VectorFst</code>","text":"<p>Optimize an fst in-place in the log semiring. Args:     fst: Fst to optimize.</p> Source code in <code>rustfst/algorithms/optimize.py</code> <pre><code>def optimize_in_log(fst: VectorFst) -&gt; VectorFst:\n    \"\"\"\n    Optimize an fst in-place in the log semiring.\n    Args:\n        fst: Fst to optimize.\n    \"\"\"\n    ret_code = lib.fst_optimize_in_log(ctypes.byref(fst.ptr))\n    err_msg = \"Error during optimize_in_log\"\n    check_ffi_error(ret_code, err_msg)\n    return fst\n</code></pre>"},{"location":"rustfst/algorithms/project/","title":"project","text":""},{"location":"rustfst/algorithms/project/#rustfst.algorithms.project-classes","title":"Classes","text":""},{"location":"rustfst/algorithms/project/#rustfst.algorithms.project.ProjectType","title":"<code>ProjectType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Different types of labels projection in a Fst.</p> Source code in <code>rustfst/algorithms/project.py</code> <pre><code>class ProjectType(Enum):\n    \"\"\"\n    Different types of labels projection in a Fst.\n    \"\"\"\n\n    PROJECT_INPUT = 0\n    \"\"\"\n    Input projection : output labels are replaced with input ones.\n    \"\"\"\n    PROJECT_OUTPUT = 1\n    \"\"\"\n    Output projection : input labels are replaced with output ones.\n    \"\"\"\n</code></pre>"},{"location":"rustfst/algorithms/project/#rustfst.algorithms.project.ProjectType-attributes","title":"Attributes","text":""},{"location":"rustfst/algorithms/project/#rustfst.algorithms.project.ProjectType.PROJECT_INPUT","title":"<code>PROJECT_INPUT = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Input projection : output labels are replaced with input ones.</p>"},{"location":"rustfst/algorithms/project/#rustfst.algorithms.project.ProjectType.PROJECT_OUTPUT","title":"<code>PROJECT_OUTPUT = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Output projection : input labels are replaced with output ones.</p>"},{"location":"rustfst/algorithms/project/#rustfst.algorithms.project-functions","title":"Functions","text":""},{"location":"rustfst/algorithms/project/#rustfst.algorithms.project.project","title":"<code>project(fst: VectorFst, proj_type: ProjectType) -&gt; VectorFst</code>","text":"<p>Convert a Fst to an acceptor using input or output labels. Args:     fst: Fst on which to apply the algorithm.     proj_type: Whether to replace input labels or output labels. Returns:     The resulting Fst.</p> Source code in <code>rustfst/algorithms/project.py</code> <pre><code>def project(fst: VectorFst, proj_type: ProjectType) -&gt; VectorFst:\n    \"\"\"\n    Convert a Fst to an acceptor using input or output labels.\n    Args:\n        fst: Fst on which to apply the algorithm.\n        proj_type: Whether to replace input labels or output labels.\n    Returns:\n        The resulting Fst.\n    \"\"\"\n    config = ctypes.pointer(ctypes.c_void_p())\n    ret_code = lib.fst_project_type_new(\n        ctypes.c_size_t(proj_type.value),\n        ctypes.byref(config),\n    )\n    err_msg = \"Error creating ProjectType\"\n    check_ffi_error(ret_code, err_msg)\n\n    ret_code = lib.fst_project(fst.ptr, config)\n    err_msg = \"Error during projection\"\n    check_ffi_error(ret_code, err_msg)\n\n    return fst\n</code></pre>"},{"location":"rustfst/algorithms/randgen/","title":"randgen","text":""},{"location":"rustfst/algorithms/randgen/#rustfst.algorithms.randgen-classes","title":"Classes","text":""},{"location":"rustfst/algorithms/randgen/#rustfst.algorithms.randgen-functions","title":"Functions","text":""},{"location":"rustfst/algorithms/randgen/#rustfst.algorithms.randgen.randgen","title":"<code>randgen(ifst: Fst, npath: int = 1, seed: int = 0, select: str = 'uniform', max_length: int = 2147483647, weight: bool = False, remove_total_weight: bool = False) -&gt; VectorFst</code>","text":"<p>Randomly generate successful paths in an FST. This operation randomly generates a set of successful paths in the input FST. This relies on a mechanism for selecting arcs, specified using the <code>select</code> argument. The default selector, \"uniform\", randomly selects a transition using a uniform distribution. The \"log_prob\" selector randomly selects a transition w.r.t. the weights treated as negative log probabilities after normalizing for the total weight leaving the state. In all cases, finality is treated as a transition to a super-final state.</p> <p>Parameters:</p> Name Type Description Default <code>ifst</code> <code>Fst</code> <p>The input FST.</p> required <code>npath</code> <code>int</code> <p>The number of random paths to generate.</p> <code>1</code> <code>seed</code> <code>int</code> <p>An optional seed value for random path generation; if zero, the current time and process ID is used.</p> <code>0</code> <code>select</code> <code>str</code> <p>A string matching a known random arc selection type; one of: \"uniform\", \"log_prob\", \"fast_log_prob\".</p> <code>'uniform'</code> <code>max_length</code> <code>int</code> <p>The maximum length of each random path.</p> <code>2147483647</code> <code>weight</code> <code>bool</code> <p>Should the output be weighted by path count?</p> <code>False</code> <code>remove_total_weight</code> <code>bool</code> <p>Should the total weight be removed (ignored when <code>weighted</code> is False)?</p> <code>False</code> <p>Returns:</p> Type Description <code>VectorFst</code> <p>An FST containing one or more random paths.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>when something wrong happened.</p> Source code in <code>rustfst/algorithms/randgen.py</code> <pre><code>def randgen(\n    ifst: Fst,\n    npath: int = 1,\n    seed: int = 0,\n    select: str = \"uniform\",\n    max_length: int = 2147483647,\n    weight: bool = False,\n    remove_total_weight: bool = False,\n) -&gt; VectorFst:\n    \"\"\"\n    Randomly generate successful paths in an FST.\n    This operation randomly generates a set of successful paths in the input FST.\n    This relies on a mechanism for selecting arcs, specified using the `select`\n    argument. The default selector, \"uniform\", randomly selects a transition\n    using a uniform distribution. The \"log_prob\" selector randomly selects a\n    transition w.r.t. the weights treated as negative log probabilities after\n    normalizing for the total weight leaving the state. In all cases, finality is\n    treated as a transition to a super-final state.\n\n    Args:\n        ifst: The input FST.\n        npath: The number of random paths to generate.\n        seed: An optional seed value for random path generation; if zero, the\n            current time and process ID is used.\n        select: A string matching a known random arc selection type; one of:\n            \"uniform\", \"log_prob\", \"fast_log_prob\".\n        max_length: The maximum length of each random path.\n        weight: Should the output be weighted by path count?\n        remove_total_weight: Should the total weight be removed (ignored when\n            `weighted` is False)?\n\n    Returns:\n        An FST containing one or more random paths.\n\n    Raises:\n      ValueError: when something wrong happened.\n    \"\"\"\n\n    if select != \"uniform\":\n        raise ValueError(\n            f\"Only the uniform distribution is supported for now. Found {select}\"\n        )\n\n    npath = ctypes.c_size_t(npath)\n    seed = ctypes.c_size_t(seed)\n    max_length = ctypes.c_size_t(max_length)\n    weight = ctypes.c_bool(weight)\n    remove_total_weight = ctypes.c_bool(remove_total_weight)\n    randgen_fst = ctypes.pointer(ctypes.c_void_p())\n\n    ret_code = lib.fst_randgen(\n        ifst.ptr,\n        npath,\n        seed,\n        max_length,\n        weight,\n        remove_total_weight,\n        ctypes.byref(randgen_fst),\n    )\n    err_msg = \"Error during randgen\"\n    check_ffi_error(ret_code, err_msg)\n\n    return VectorFst(ptr=randgen_fst)\n</code></pre>"},{"location":"rustfst/algorithms/replace/","title":"replace","text":""},{"location":"rustfst/algorithms/replace/#rustfst.algorithms.replace-classes","title":"Classes","text":""},{"location":"rustfst/algorithms/replace/#rustfst.algorithms.replace-functions","title":"Functions","text":""},{"location":"rustfst/algorithms/replace/#rustfst.algorithms.replace.replace","title":"<code>replace(root_idx: int, fst_list: List[Tuple[int, VectorFst]], epsilon_on_replace: bool) -&gt; VectorFst</code>","text":"<p>Recursively replaces trs in the root FSTs with other FSTs.</p> <p>Replace supports replacement of trs in one Fst with another FST. This replacement is recursive. Replace takes an array of FST(s). One FST represents the root (or topology) machine. The root FST refers to other FSTs by recursively replacing trs labeled as non-terminals with the matching non-terminal FST. Currently Replace uses the output symbols of the trs to determine whether the transition is a non-terminal transition or not. A non-terminal can be any label that is not a non-zero terminal label in the output alphabet.</p> <p>Note that input argument is a vector of pairs. These correspond to the tuple of non-terminal Label and corresponding FST.</p> <p>Examples:</p> <ul> <li>Root Fst :</li> </ul> <p></p> <ul> <li>Fst for non-terminal #NAME :</li> </ul> <p></p> <ul> <li>Fst for non-terminal #FIRSTNAME :</li> </ul> <p></p> <ul> <li>Fst for non-terminal #LASTNAME :</li> </ul> <p></p> <ul> <li>Output :</li> </ul> <p></p> <p>Parameters:</p> Name Type Description Default <code>root_idx</code> <code>int</code> required <code>fst_list</code> <code>List[Tuple[int, VectorFst]]</code> required <code>epsilon_on_replace</code> <code>bool</code> required <p>Returns:</p> Type Description <code>VectorFst</code> <p>The resulting Fst.</p> Source code in <code>rustfst/algorithms/replace.py</code> <pre><code>def replace(\n    root_idx: int, fst_list: List[Tuple[int, VectorFst]], epsilon_on_replace: bool\n) -&gt; VectorFst:\n    \"\"\"\n    Recursively replaces trs in the root FSTs with other FSTs.\n\n    Replace supports replacement of trs in one Fst with another FST. This\n    replacement is recursive. Replace takes an array of FST(s). One FST\n    represents the root (or topology) machine. The root FST refers to other FSTs\n    by recursively replacing trs labeled as non-terminals with the matching\n    non-terminal FST. Currently Replace uses the output symbols of the trs to\n    determine whether the transition is a non-terminal transition or not. A non-terminal can be\n    any label that is not a non-zero terminal label in the output alphabet.\n\n    Note that input argument is a vector of pairs. These correspond to the tuple\n    of non-terminal Label and corresponding FST.\n\n    Examples:\n\n    - Root Fst :\n\n    ![replace_in_1](https://raw.githubusercontent.com/Garvys/rustfst-images-doc/master/images/replace_in_1.svg?sanitize=true)\n\n    - Fst for non-terminal #NAME :\n\n    ![replace_in_2](https://raw.githubusercontent.com/Garvys/rustfst-images-doc/master/images/replace_in_2.svg?sanitize=true)\n\n    - Fst for non-terminal #FIRSTNAME :\n\n    ![replace_in_3](https://raw.githubusercontent.com/Garvys/rustfst-images-doc/master/images/replace_in_3.svg?sanitize=true)\n\n    - Fst for non-terminal #LASTNAME :\n\n    ![replace_in_4](https://raw.githubusercontent.com/Garvys/rustfst-images-doc/master/images/replace_in_4.svg?sanitize=true)\n\n    - Output :\n\n    ![replace_out](https://raw.githubusercontent.com/Garvys/rustfst-images-doc/master/images/replace_out.svg?sanitize=true)\n\n    Args:\n        root_idx:\n        fst_list:\n        epsilon_on_replace:\n\n    Returns:\n        The resulting Fst.\n\n    \"\"\"\n    pairs = [LabelFstPair(label, fst.ptr) for (label, fst) in fst_list]\n    pairs_array = (LabelFstPair * len(pairs))(*pairs)\n    res_fst = ctypes.pointer(ctypes.c_void_p())\n    ret_code = lib.fst_replace(\n        ctypes.c_size_t(root_idx),\n        ctypes.byref(pairs_array),\n        ctypes.c_size_t(len(pairs)),\n        ctypes.c_bool(epsilon_on_replace),\n        ctypes.byref(res_fst),\n    )\n    err_msg = \"Error performing replace\"\n    check_ffi_error(ret_code, err_msg)\n\n    return VectorFst(ptr=res_fst)\n</code></pre>"},{"location":"rustfst/algorithms/reverse/","title":"reverse","text":""},{"location":"rustfst/algorithms/reverse/#rustfst.algorithms.reverse-classes","title":"Classes","text":""},{"location":"rustfst/algorithms/reverse/#rustfst.algorithms.reverse-functions","title":"Functions","text":""},{"location":"rustfst/algorithms/reverse/#rustfst.algorithms.reverse.reverse","title":"<code>reverse(fst: VectorFst) -&gt; VectorFst</code>","text":"<p>Reverse an Fst, returning a new Fst which accepts the same language in reverse order.</p> <p>Not to be confused with <code>inverse</code>, which does something totally different! Args:   fst: Fst to reverse Returns:   Newly created, reversed Fst.</p> Source code in <code>rustfst/algorithms/reverse.py</code> <pre><code>def reverse(fst: VectorFst) -&gt; VectorFst:\n    \"\"\"\n    Reverse an Fst, returning a new Fst which accepts\n    the same language in reverse order.\n\n    Not to be confused with `inverse`, which does something\n    totally different!\n    Args:\n      fst: Fst to reverse\n    Returns:\n      Newly created, reversed Fst.\n    \"\"\"\n\n    reversed_fst = ctypes.c_void_p()\n    ret_code = lib.fst_reverse(fst.ptr, ctypes.byref(reversed_fst))\n    err_msg = \"Error during reverse\"\n    check_ffi_error(ret_code, err_msg)\n\n    return VectorFst(ptr=reversed_fst)\n</code></pre>"},{"location":"rustfst/algorithms/rm_epsilon/","title":"rm_epsilon","text":""},{"location":"rustfst/algorithms/rm_epsilon/#rustfst.algorithms.rm_epsilon-classes","title":"Classes","text":""},{"location":"rustfst/algorithms/rm_epsilon/#rustfst.algorithms.rm_epsilon-functions","title":"Functions","text":""},{"location":"rustfst/algorithms/rm_epsilon/#rustfst.algorithms.rm_epsilon.rm_epsilon","title":"<code>rm_epsilon(fst: VectorFst) -&gt; VectorFst</code>","text":"<p>Remove epsilon transitions in-place Args:   fst: Fst to remove epsilons from Returns:   fst: Same FST, modified in place</p> Source code in <code>rustfst/algorithms/rm_epsilon.py</code> <pre><code>def rm_epsilon(fst: VectorFst) -&gt; VectorFst:\n    \"\"\"\n    Remove epsilon transitions in-place\n    Args:\n      fst: Fst to remove epsilons from\n    Returns:\n      fst: Same FST, modified in place\n    \"\"\"\n\n    ret_code = lib.fst_rm_epsilon(fst.ptr)\n    err_msg = \"Error during rm_epsilon\"\n    check_ffi_error(ret_code, err_msg)\n\n    return fst\n</code></pre>"},{"location":"rustfst/algorithms/shortest_path/","title":"shortest_path","text":""},{"location":"rustfst/algorithms/shortest_path/#rustfst.algorithms.shortest_path-classes","title":"Classes","text":""},{"location":"rustfst/algorithms/shortest_path/#rustfst.algorithms.shortest_path.ShortestPathConfig","title":"<code>ShortestPathConfig</code>","text":"<p>Configuration for shortest-path operation.</p> <p>Parameters:</p> Name Type Description Default <code>nshortest</code> <code>int</code> <p>Number of shortest paths to return</p> <code>1</code> <code>unique</code> <code>bool</code> <p>Return only unique label sequences</p> <code>False</code> <code>delta</code> <code>Union[float, None]</code> <p>Difference in weights considered significant</p> <code>None</code> Source code in <code>rustfst/algorithms/shortest_path.py</code> <pre><code>class ShortestPathConfig:\n    \"\"\"\n    Configuration for shortest-path operation.\n\n    Args:\n      nshortest: Number of shortest paths to return\n      unique: Return only unique label sequences\n      delta: Difference in weights considered significant\n    \"\"\"\n\n    def __init__(\n        self, nshortest: int = 1, unique: bool = False, delta: Union[float, None] = None\n    ):\n        if delta is None:\n            delta = KSHORTESTDELTA\n        config = ctypes.pointer(ctypes.c_void_p())\n        ret_code = lib.fst_shortest_path_config_new(\n            ctypes.c_float(delta),\n            ctypes.c_size_t(nshortest),\n            ctypes.c_bool(unique),\n            ctypes.byref(config),\n        )\n        err_msg = \"Error creating ShortestPathConfig\"\n        check_ffi_error(ret_code, err_msg)\n        self.ptr = config\n</code></pre>"},{"location":"rustfst/algorithms/shortest_path/#rustfst.algorithms.shortest_path-functions","title":"Functions","text":""},{"location":"rustfst/algorithms/shortest_path/#rustfst.algorithms.shortest_path.shortestpath","title":"<code>shortestpath(fst: VectorFst) -&gt; VectorFst</code>","text":"<p>Construct a FST containing the shortest path of the input FST Args:   fst: Fst Returns:   Newly-created FST containing only the shortest path of the input FST.</p> Source code in <code>rustfst/algorithms/shortest_path.py</code> <pre><code>def shortestpath(fst: VectorFst) -&gt; VectorFst:\n    \"\"\"\n    Construct a FST containing the shortest path of the input FST\n    Args:\n      fst: Fst\n    Returns:\n      Newly-created FST containing only the shortest path of the input FST.\n    \"\"\"\n\n    shortest_path = ctypes.c_void_p()\n    ret_code = lib.fst_shortest_path(fst.ptr, ctypes.byref(shortest_path))\n    err_msg = \"Error computing shortest path\"\n    check_ffi_error(ret_code, err_msg)\n\n    return VectorFst(ptr=shortest_path)\n</code></pre>"},{"location":"rustfst/algorithms/shortest_path/#rustfst.algorithms.shortest_path.shortestpath_with_config","title":"<code>shortestpath_with_config(fst: VectorFst, config: ShortestPathConfig) -&gt; VectorFst</code>","text":"<p>Construct a FST containing the shortest path of the input FST Args:   fst: Fst   config: Configuration for shortest-path operation. Returns:   Newly-created FST containing only the shortest path of the input FST.</p> Source code in <code>rustfst/algorithms/shortest_path.py</code> <pre><code>def shortestpath_with_config(fst: VectorFst, config: ShortestPathConfig) -&gt; VectorFst:\n    \"\"\"\n    Construct a FST containing the shortest path of the input FST\n    Args:\n      fst: Fst\n      config: Configuration for shortest-path operation.\n    Returns:\n      Newly-created FST containing only the shortest path of the input FST.\n    \"\"\"\n\n    shortest_path = ctypes.c_void_p()\n\n    ret_code = lib.fst_shortest_path_with_config(\n        fst.ptr, config.ptr, ctypes.byref(shortest_path)\n    )\n    err_msg = \"Error computing shortest path\"\n    check_ffi_error(ret_code, err_msg)\n\n    return VectorFst(ptr=shortest_path)\n</code></pre>"},{"location":"rustfst/algorithms/top_sort/","title":"top_sort","text":""},{"location":"rustfst/algorithms/top_sort/#rustfst.algorithms.top_sort-classes","title":"Classes","text":""},{"location":"rustfst/algorithms/top_sort/#rustfst.algorithms.top_sort-functions","title":"Functions","text":""},{"location":"rustfst/algorithms/top_sort/#rustfst.algorithms.top_sort.top_sort","title":"<code>top_sort(fst: VectorFst) -&gt; VectorFst</code>","text":"<p>This operation topologically sorts its input. When sorted, all transitions are from lower to higher state IDs.</p> <p>Examples :</p> <ul> <li>Input</li> </ul> <p></p> <ul> <li>Output</li> </ul> <p></p> <p>Parameters:</p> Name Type Description Default <code>fst</code> <code>VectorFst</code> <p>Fst to top_sort.</p> required <p>Returns:     Equivalent top sorted Fst. Modification also happens in-place.</p> Source code in <code>rustfst/algorithms/top_sort.py</code> <pre><code>def top_sort(fst: VectorFst) -&gt; VectorFst:\n    \"\"\"\n    This operation topologically sorts its input. When sorted, all transitions are from lower to higher state IDs.\n\n    Examples :\n\n    - Input\n\n    ![topsort_in](https://raw.githubusercontent.com/Garvys/rustfst-images-doc/master/images/topsort_in.svg?sanitize=true)\n\n    - Output\n\n    ![topsort_out](https://raw.githubusercontent.com/Garvys/rustfst-images-doc/master/images/topsort_out.svg?sanitize=true)\n\n    Args:\n        fst: Fst to top_sort.\n    Returns:\n        Equivalent top sorted Fst. Modification also happens in-place.\n    \"\"\"\n\n    top_sorted_fst = ctypes.c_void_p()\n    ret_code = lib.fst_top_sort(fst.ptr, ctypes.byref(top_sorted_fst))\n    err_msg = \"Error during top_sort\"\n    check_ffi_error(ret_code, err_msg)\n\n    return VectorFst(ptr=top_sorted_fst)\n</code></pre>"},{"location":"rustfst/algorithms/tr_sort/","title":"tr_sort","text":""},{"location":"rustfst/algorithms/tr_sort/#rustfst.algorithms.tr_sort-classes","title":"Classes","text":""},{"location":"rustfst/algorithms/tr_sort/#rustfst.algorithms.tr_sort-functions","title":"Functions","text":""},{"location":"rustfst/algorithms/tr_sort/#rustfst.algorithms.tr_sort.tr_sort","title":"<code>tr_sort(fst: VectorFst, ilabel_cmp: bool) -&gt; VectorFst</code>","text":"<p>Sort fst trs in place according to their input or output label. output label.</p> <p>This is often necessary for composition to work properly.  It corresponds to <code>ArcSort</code> in OpenFST.</p> <p>Parameters:</p> Name Type Description Default <code>fst</code> <code>VectorFst</code> <p>FST to be tr-sorted in-place.</p> required <code>ilabel_cmp</code> <code>bool</code> <p>Sort on input labels if <code>True</code>, output labels          if <code>False</code>.</p> required <p>Returns:   fst: Same FST that was modified in-place.</p> Source code in <code>rustfst/algorithms/tr_sort.py</code> <pre><code>def tr_sort(fst: VectorFst, ilabel_cmp: bool) -&gt; VectorFst:\n    \"\"\"Sort fst trs in place according to their input or output label.\n    output label.\n\n    This is often necessary for composition to work properly.  It\n    corresponds to `ArcSort` in OpenFST.\n\n    Args:\n      fst: FST to be tr-sorted in-place.\n      ilabel_cmp: Sort on input labels if `True`, output labels\n                 if `False`.\n    Returns:\n      fst: Same FST that was modified in-place.\n    \"\"\"\n\n    ret_code = lib.fst_tr_sort(fst.ptr, ctypes.c_bool(ilabel_cmp))\n    err_msg = \"Error during tr_sort\"\n    check_ffi_error(ret_code, err_msg)\n    return fst\n</code></pre>"},{"location":"rustfst/algorithms/tr_unique/","title":"tr_unique","text":""},{"location":"rustfst/algorithms/tr_unique/#rustfst.algorithms.tr_unique-classes","title":"Classes","text":""},{"location":"rustfst/algorithms/tr_unique/#rustfst.algorithms.tr_unique-functions","title":"Functions","text":""},{"location":"rustfst/algorithms/tr_unique/#rustfst.algorithms.tr_unique.tr_unique","title":"<code>tr_unique(fst: VectorFst) -&gt; VectorFst</code>","text":"<p>Modify an FST in-place, keeping a single instance of trs leaving the same state, going to the same state and with the same input labels, output labels and weight.</p> <p>Parameters:</p> Name Type Description Default <code>fst</code> <code>VectorFst</code> <p>Fst to modify</p> required <p>Returns:     fst: Same FST, modified in-place</p> Source code in <code>rustfst/algorithms/tr_unique.py</code> <pre><code>def tr_unique(fst: VectorFst) -&gt; VectorFst:\n    \"\"\"\n    Modify an FST in-place, keeping a single instance of trs\n    leaving the same state, going to the same state and with the same\n    input labels, output labels and weight.\n\n    Args:\n        fst: Fst to modify\n    Returns:\n        fst: Same FST, modified in-place\n    \"\"\"\n\n    ret_code = lib.fst_tr_unique(fst.ptr)\n    err_msg = \"Error during tr_unique\"\n    check_ffi_error(ret_code, err_msg)\n    return fst\n</code></pre>"},{"location":"rustfst/algorithms/union/","title":"union","text":""},{"location":"rustfst/algorithms/union/#rustfst.algorithms.union-classes","title":"Classes","text":""},{"location":"rustfst/algorithms/union/#rustfst.algorithms.union-functions","title":"Functions","text":""},{"location":"rustfst/algorithms/union/#rustfst.algorithms.union.union","title":"<code>union(fst: VectorFst, other_fst: VectorFst) -&gt; VectorFst</code>","text":"<p>Performs the union of two wFSTs. If A transduces string <code>x</code> to <code>y</code> with weight <code>a</code> and <code>B</code> transduces string <code>w</code> to <code>v</code> with weight <code>b</code>, then their union transduces <code>x</code> to <code>y</code> with weight <code>a</code> and <code>w</code> to <code>v</code> with weight <code>b</code>.</p> <p>Examples: - Input Fst 1:</p> <p></p> <ul> <li>Input Fst 2:</li> </ul> <p></p> <ul> <li>Union:</li> </ul> <p></p> <p>Parameters:</p> Name Type Description Default <code>fst</code> <code>VectorFst</code> required <code>other_fst</code> <code>VectorFst</code> required <p>Returns:      The resulting Fst.</p> Source code in <code>rustfst/algorithms/union.py</code> <pre><code>def union(fst: VectorFst, other_fst: VectorFst) -&gt; VectorFst:\n    \"\"\"\n    Performs the union of two wFSTs. If A transduces string `x` to `y` with weight `a`\n    and `B` transduces string `w` to `v` with weight `b`, then their union transduces `x` to `y`\n    with weight `a` and `w` to `v` with weight `b`.\n\n    Examples:\n    - Input Fst 1:\n\n    ![union_in_1](https://raw.githubusercontent.com/Garvys/rustfst-images-doc/master/images/union_in_1.svg?sanitize=true)\n\n    - Input Fst 2:\n\n    ![union_in_2](https://raw.githubusercontent.com/Garvys/rustfst-images-doc/master/images/union_in_2.svg?sanitize=true)\n\n    - Union:\n\n    ![union_out](https://raw.githubusercontent.com/Garvys/rustfst-images-doc/master/images/union_out.svg?sanitize=true)\n\n    Args:\n        fst:\n        other_fst:\n    Returns:\n         The resulting Fst.\n\n    \"\"\"\n\n    ret_code = lib.fst_union(fst.ptr, other_fst.ptr)\n    err_msg = \"Error during union\"\n    check_ffi_error(ret_code, err_msg)\n\n    return fst\n</code></pre>"},{"location":"rustfst/algorithms/union/#rustfst.algorithms.union.union_list","title":"<code>union_list(fsts: List[VectorFst]) -&gt; VectorFst</code>","text":"<p>Computes the union of a list of Fsts.</p> <p>Parameters:</p> Name Type Description Default <code>fsts</code> <code>List[VectorFst]</code> <p>The list of Fsts to produce the union.</p> required <p>Returns:</p> Type Description <code>VectorFst</code> <p>The resulting Fst.</p> Source code in <code>rustfst/algorithms/union.py</code> <pre><code>def union_list(fsts: List[VectorFst]) -&gt; VectorFst:\n    \"\"\"\n    Computes the union of a list of Fsts.\n\n    Args:\n        fsts: The list of Fsts to produce the union.\n\n    Returns:\n        The resulting Fst.\n\n    \"\"\"\n    if not fsts:\n        raise ValueError(\"fsts must be at least of len 1\")\n    fsts = [f.copy() for f in fsts]\n    res_fst = fsts[0]\n    for f in fsts[1:]:\n        res_fst = union(res_fst, f)\n    return res_fst\n</code></pre>"},{"location":"rustfst/drawing_config/","title":"drawing_config","text":""},{"location":"rustfst/drawing_config/#rustfst.drawing_config-classes","title":"Classes","text":""},{"location":"rustfst/drawing_config/#rustfst.drawing_config.DrawingConfig","title":"<code>DrawingConfig</code>","text":"Source code in <code>rustfst/drawing_config.py</code> <pre><code>class DrawingConfig:\n    def __init__(\n        self,\n        acceptor: bool = False,\n        title: str = \"\",\n        width: Optional[float] = None,\n        height: Optional[float] = None,\n        portrait: bool = True,\n        vertical: bool = False,\n        ranksep: Optional[float] = None,\n        nodesep: Optional[float] = None,\n        fontsize: int = 14,\n        show_weight_one: bool = True,\n        print_weight: bool = True,\n    ):\n        \"\"\"\n        Args:\n            acceptor: Should the figure be rendered in acceptor format if possible?\n            title: An optional string indicating the figure title.\n            width: The figure width, in inches.\n            height: The figure height, in inches.\n            portrait: Should the figure be rendered in portrait rather than\n                landscape?\n            vertical: Should the figure be rendered bottom-to-top rather than\n                left-to-right?\n            ranksep: The minimum separation separation between ranks, in inches.\n            nodesep: The minimum separation between nodes, in inches.\n            fontsize: Font size, in points.\n            show_weight_one: Should weights equivalent to semiring One be printed?\n            print_weight: Should weights be printed\n        \"\"\"\n        self.acceptor = acceptor\n        self.title = title\n        self.width = width\n        self.height = height\n        self.portrait = portrait\n        self.vertical = vertical\n        self.ranksep = ranksep\n        self.nodesep = nodesep\n        self.fontsize = fontsize\n        self.show_weight_one = show_weight_one\n        self.print_weight = print_weight\n</code></pre>"},{"location":"rustfst/drawing_config/#rustfst.drawing_config.DrawingConfig-functions","title":"Functions","text":""},{"location":"rustfst/drawing_config/#rustfst.drawing_config.DrawingConfig.__init__","title":"<code>__init__(acceptor: bool = False, title: str = '', width: Optional[float] = None, height: Optional[float] = None, portrait: bool = True, vertical: bool = False, ranksep: Optional[float] = None, nodesep: Optional[float] = None, fontsize: int = 14, show_weight_one: bool = True, print_weight: bool = True)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>acceptor</code> <code>bool</code> <p>Should the figure be rendered in acceptor format if possible?</p> <code>False</code> <code>title</code> <code>str</code> <p>An optional string indicating the figure title.</p> <code>''</code> <code>width</code> <code>Optional[float]</code> <p>The figure width, in inches.</p> <code>None</code> <code>height</code> <code>Optional[float]</code> <p>The figure height, in inches.</p> <code>None</code> <code>portrait</code> <code>bool</code> <p>Should the figure be rendered in portrait rather than landscape?</p> <code>True</code> <code>vertical</code> <code>bool</code> <p>Should the figure be rendered bottom-to-top rather than left-to-right?</p> <code>False</code> <code>ranksep</code> <code>Optional[float]</code> <p>The minimum separation separation between ranks, in inches.</p> <code>None</code> <code>nodesep</code> <code>Optional[float]</code> <p>The minimum separation between nodes, in inches.</p> <code>None</code> <code>fontsize</code> <code>int</code> <p>Font size, in points.</p> <code>14</code> <code>show_weight_one</code> <code>bool</code> <p>Should weights equivalent to semiring One be printed?</p> <code>True</code> <code>print_weight</code> <code>bool</code> <p>Should weights be printed</p> <code>True</code> Source code in <code>rustfst/drawing_config.py</code> <pre><code>def __init__(\n    self,\n    acceptor: bool = False,\n    title: str = \"\",\n    width: Optional[float] = None,\n    height: Optional[float] = None,\n    portrait: bool = True,\n    vertical: bool = False,\n    ranksep: Optional[float] = None,\n    nodesep: Optional[float] = None,\n    fontsize: int = 14,\n    show_weight_one: bool = True,\n    print_weight: bool = True,\n):\n    \"\"\"\n    Args:\n        acceptor: Should the figure be rendered in acceptor format if possible?\n        title: An optional string indicating the figure title.\n        width: The figure width, in inches.\n        height: The figure height, in inches.\n        portrait: Should the figure be rendered in portrait rather than\n            landscape?\n        vertical: Should the figure be rendered bottom-to-top rather than\n            left-to-right?\n        ranksep: The minimum separation separation between ranks, in inches.\n        nodesep: The minimum separation between nodes, in inches.\n        fontsize: Font size, in points.\n        show_weight_one: Should weights equivalent to semiring One be printed?\n        print_weight: Should weights be printed\n    \"\"\"\n    self.acceptor = acceptor\n    self.title = title\n    self.width = width\n    self.height = height\n    self.portrait = portrait\n    self.vertical = vertical\n    self.ranksep = ranksep\n    self.nodesep = nodesep\n    self.fontsize = fontsize\n    self.show_weight_one = show_weight_one\n    self.print_weight = print_weight\n</code></pre>"},{"location":"rustfst/fst/","title":"fst","text":""},{"location":"rustfst/fst/#rustfst.fst-classes","title":"Classes","text":""},{"location":"rustfst/fst/#rustfst.fst.Fst","title":"<code>Fst</code>","text":"<p>This class is the base class for every Fst objects.</p> Source code in <code>rustfst/fst/__init__.py</code> <pre><code>class Fst:\n    \"\"\"\n    This class is the base class for every Fst objects.\n    \"\"\"\n\n    def __init__(self, ptr, isymt=None, osymt=None):\n        self.ptr = ptr\n        self._input_symbols = isymt\n        self._output_symbols = osymt\n\n    def start(self) -&gt; Optional[int]:\n        \"\"\"\n        Returns the start state.\n        Returns :\n            The start state or None.\n        \"\"\"\n        start = ctypes.c_size_t()\n        ret_code = lib.fst_start(self.ptr, ctypes.byref(start))\n        err_msg = \"Error getting start state\"\n        check_ffi_error(ret_code, err_msg)\n\n        if start is None:\n            return None\n        return int(start.value)\n\n    def final(self, state: int) -&gt; Optional[float]:\n        \"\"\"\n        Returns the final weight of a state.\n        Args:\n          state: The integer index of a state.\n        Returns:\n          The final Weight of that state.\n        Raises:\n          Exception: If State index out of range.\n        \"\"\"\n        state = ctypes.c_size_t(state)\n        weight = ctypes.c_float()\n\n        ret_code = lib.fst_final_weight(self.ptr, state, ctypes.byref(weight))\n        err_msg = \"Error getting final weight\"\n        check_ffi_error(ret_code, err_msg)\n\n        if weight is None:\n            return None\n\n        return weight.value\n\n    def num_trs(self, state: int) -&gt; int:\n        \"\"\"\n        Returns the number of trs leaving a state.\n        Args:\n          state: The integer index of a state.\n        Returns:\n          The number of trs leaving that state.\n        Raises:\n          Exception: If State index out of range.\n        See also: `num_states`.\n        \"\"\"\n        num_trs = ctypes.c_size_t()\n        state = ctypes.c_size_t(state)\n        ret_code = lib.fst_num_trs(self.ptr, state, ctypes.byref(num_trs))\n        err_msg = \"Error getting number of trs\"\n        check_ffi_error(ret_code, err_msg)\n\n        return int(num_trs.value)\n\n    def trs(self, state: int) -&gt; TrsIterator:\n        \"\"\"\n        Returns an iterator over trs leaving the specified state.\n        Args:\n          state: The source state ID.\n        Returns:\n          An TrsIterator.\n        See also: `mutable_trs`, `states`.\n        \"\"\"\n        return TrsIterator(self, state)\n\n    def is_final(self, state_id: int) -&gt; bool:\n        \"\"\"\n        Check if a state is final\n        Args :\n            state_id:\n        Returns :\n            bool\n        \"\"\"\n        state = ctypes.c_size_t(state_id)\n        is_final = ctypes.c_size_t()\n\n        ret_code = lib.fst_is_final(self.ptr, state, ctypes.byref(is_final))\n        err_msg = \"Error checking if state is final\"\n        check_ffi_error(ret_code, err_msg)\n\n        return bool(is_final.value)\n\n    def is_start(self, state_id: int) -&gt; bool:\n        \"\"\"\n        Check if a state is a start state.\n        Args :\n            state_id: Integer index of the state.\n        Returns :\n            bool\n        \"\"\"\n        state = ctypes.c_size_t(state_id)\n        is_start = ctypes.c_size_t()\n\n        ret_code = lib.fst_is_start(self.ptr, state, ctypes.byref(is_start))\n        err_msg = \"Error checking if state is final\"\n        check_ffi_error(ret_code, err_msg)\n\n        return bool(is_start.value)\n\n    def input_symbols(self) -&gt; Optional[SymbolTable]:\n        \"\"\"\n        Returns the Fst's input symbol table, or None if none is present.\n        Returns :\n            The Fst's input symbol table, or None if none is present.\n        See also: `output_symbols`.\n        \"\"\"\n        if self._input_symbols:\n            return self._input_symbols\n\n        table = ctypes.pointer(ctypes.c_void_p())\n        ret_code = lib.fst_input_symbols(self.ptr, ctypes.byref(table))\n        err_msg = \"Error getting input symbols\"\n        check_ffi_error(ret_code, err_msg)\n\n        if table.contents:\n            return SymbolTable(ptr=table)\n        return None\n\n    def output_symbols(self) -&gt; Optional[SymbolTable]:\n        \"\"\"\n        Returns the Fst's output symbol table, or None if none is present.\n        Returns :\n            The Fst's output symbol table, or None if none is present.\n        See also: `input_symbols`.\n        \"\"\"\n        if self._output_symbols:\n            return self._output_symbols\n\n        table = ctypes.pointer(ctypes.c_void_p())\n\n        ret_code = lib.fst_output_symbols(self.ptr, ctypes.byref(table))\n        err_msg = \"Error getting output symbols\"\n        check_ffi_error(ret_code, err_msg)\n\n        if table.contents:\n            return SymbolTable(ptr=table)\n        return None\n\n    def set_input_symbols(self, syms: Optional[SymbolTable]) -&gt; Fst:\n        \"\"\"\n        Sets the input symbol table.\n        Passing None as a value will delete the input symbol table.\n        Args:\n          syms: A SymbolTable.\n        Returns:\n          self.\n        See also: `set_output_symbols`.\n        \"\"\"\n        if syms is None:\n            ret_code = lib.fst_unset_input_symbols(self.ptr)\n            err_msg = \"Error unsetting input symbols\"\n            check_ffi_error(ret_code, err_msg)\n            # detach symbol table from fst\n            self._input_symbols = None\n            return self\n\n        table = syms.ptr\n        ret_code = lib.fst_set_input_symbols(self.ptr, table)\n        err_msg = \"Error setting input symbols\"\n        check_ffi_error(ret_code, err_msg)\n\n        # attach symbol table to fst (prevent early gc of syms)\n        self._input_symbols = syms\n\n        return self\n\n    def set_output_symbols(self, syms: Optional[SymbolTable]) -&gt; Fst:\n        \"\"\"\n        Sets the output symbol table.\n        Passing None as a value will delete the output symbol table.\n        Args:\n          syms: A SymbolTable.\n        Returns:\n          self.\n        See also: `set_input_symbols`.\n        \"\"\"\n        if syms is None:\n            ret_code = lib.fst_unset_output_symbols(self.ptr)\n            err_msg = \"Error unsetting output symbols\"\n            check_ffi_error(ret_code, err_msg)\n            # detach symbol table from fst\n            self._output_symbols = None\n            return self\n\n        table = syms.ptr\n\n        ret_code = lib.fst_set_output_symbols(self.ptr, table)\n        err_msg = \"Error setting output symbols\"\n        check_ffi_error(ret_code, err_msg)\n\n        # attach symbol table to fst (prevent early gc of syms)\n        self._output_symbols = syms\n\n        return self\n\n    def remove_input_symbols(self, symbols: list[int]) -&gt; Fst:\n        \"\"\"\n        Args:\n          symbols: List[int]\n        Returns:\n          self.\n        \"\"\"\n        symbols_ptr = (ctypes.c_int * len(symbols))(*symbols)\n        symbols_len = ctypes.c_size_t(len(symbols))\n        ret_code = lib.fst_remove_input_symbols(self.ptr, symbols_ptr, symbols_len)\n        err_msg = \"Error during remove_input_symbols\"\n        check_ffi_error(ret_code, err_msg)\n\n        return self\n\n    def remove_output_symbols(self, symbols: list[int]) -&gt; Fst:\n        \"\"\"\n        Args:\n          symbols: List[int]\n        Returns:\n          self.\n        \"\"\"\n        symbols_ptr = (ctypes.c_int * len(symbols))(*symbols)\n        symbols_len = ctypes.c_size_t(len(symbols))\n        ret_code = lib.fst_remove_output_symbols(self.ptr, symbols_ptr, symbols_len)\n        err_msg = \"Error during remove_outout_symbols\"\n        check_ffi_error(ret_code, err_msg)\n\n        return self\n\n    def __eq__(self, y: Fst):\n        \"\"\"x.__eq__(y) &lt;==&gt; x==y\"\"\"\n        return self.equals(y)\n\n    def __repr__(self):\n        return f\"&lt;rustfst.fst.Fst at {id(self)}&gt;\"\n\n    def __del__(self):\n        lib.fst_destroy(self.ptr)\n</code></pre>"},{"location":"rustfst/fst/#rustfst.fst.Fst-functions","title":"Functions","text":""},{"location":"rustfst/fst/#rustfst.fst.Fst.start","title":"<code>start() -&gt; Optional[int]</code>","text":"<p>Returns the start state. Returns :     The start state or None.</p> Source code in <code>rustfst/fst/__init__.py</code> <pre><code>def start(self) -&gt; Optional[int]:\n    \"\"\"\n    Returns the start state.\n    Returns :\n        The start state or None.\n    \"\"\"\n    start = ctypes.c_size_t()\n    ret_code = lib.fst_start(self.ptr, ctypes.byref(start))\n    err_msg = \"Error getting start state\"\n    check_ffi_error(ret_code, err_msg)\n\n    if start is None:\n        return None\n    return int(start.value)\n</code></pre>"},{"location":"rustfst/fst/#rustfst.fst.Fst.final","title":"<code>final(state: int) -&gt; Optional[float]</code>","text":"<p>Returns the final weight of a state. Args:   state: The integer index of a state. Returns:   The final Weight of that state. Raises:   Exception: If State index out of range.</p> Source code in <code>rustfst/fst/__init__.py</code> <pre><code>def final(self, state: int) -&gt; Optional[float]:\n    \"\"\"\n    Returns the final weight of a state.\n    Args:\n      state: The integer index of a state.\n    Returns:\n      The final Weight of that state.\n    Raises:\n      Exception: If State index out of range.\n    \"\"\"\n    state = ctypes.c_size_t(state)\n    weight = ctypes.c_float()\n\n    ret_code = lib.fst_final_weight(self.ptr, state, ctypes.byref(weight))\n    err_msg = \"Error getting final weight\"\n    check_ffi_error(ret_code, err_msg)\n\n    if weight is None:\n        return None\n\n    return weight.value\n</code></pre>"},{"location":"rustfst/fst/#rustfst.fst.Fst.num_trs","title":"<code>num_trs(state: int) -&gt; int</code>","text":"<p>Returns the number of trs leaving a state. Args:   state: The integer index of a state. Returns:   The number of trs leaving that state. Raises:   Exception: If State index out of range. See also: <code>num_states</code>.</p> Source code in <code>rustfst/fst/__init__.py</code> <pre><code>def num_trs(self, state: int) -&gt; int:\n    \"\"\"\n    Returns the number of trs leaving a state.\n    Args:\n      state: The integer index of a state.\n    Returns:\n      The number of trs leaving that state.\n    Raises:\n      Exception: If State index out of range.\n    See also: `num_states`.\n    \"\"\"\n    num_trs = ctypes.c_size_t()\n    state = ctypes.c_size_t(state)\n    ret_code = lib.fst_num_trs(self.ptr, state, ctypes.byref(num_trs))\n    err_msg = \"Error getting number of trs\"\n    check_ffi_error(ret_code, err_msg)\n\n    return int(num_trs.value)\n</code></pre>"},{"location":"rustfst/fst/#rustfst.fst.Fst.trs","title":"<code>trs(state: int) -&gt; TrsIterator</code>","text":"<p>Returns an iterator over trs leaving the specified state. Args:   state: The source state ID. Returns:   An TrsIterator. See also: <code>mutable_trs</code>, <code>states</code>.</p> Source code in <code>rustfst/fst/__init__.py</code> <pre><code>def trs(self, state: int) -&gt; TrsIterator:\n    \"\"\"\n    Returns an iterator over trs leaving the specified state.\n    Args:\n      state: The source state ID.\n    Returns:\n      An TrsIterator.\n    See also: `mutable_trs`, `states`.\n    \"\"\"\n    return TrsIterator(self, state)\n</code></pre>"},{"location":"rustfst/fst/#rustfst.fst.Fst.is_final","title":"<code>is_final(state_id: int) -&gt; bool</code>","text":"<p>Check if a state is final Args :     state_id: Returns :     bool</p> Source code in <code>rustfst/fst/__init__.py</code> <pre><code>def is_final(self, state_id: int) -&gt; bool:\n    \"\"\"\n    Check if a state is final\n    Args :\n        state_id:\n    Returns :\n        bool\n    \"\"\"\n    state = ctypes.c_size_t(state_id)\n    is_final = ctypes.c_size_t()\n\n    ret_code = lib.fst_is_final(self.ptr, state, ctypes.byref(is_final))\n    err_msg = \"Error checking if state is final\"\n    check_ffi_error(ret_code, err_msg)\n\n    return bool(is_final.value)\n</code></pre>"},{"location":"rustfst/fst/#rustfst.fst.Fst.is_start","title":"<code>is_start(state_id: int) -&gt; bool</code>","text":"<p>Check if a state is a start state. Args :     state_id: Integer index of the state. Returns :     bool</p> Source code in <code>rustfst/fst/__init__.py</code> <pre><code>def is_start(self, state_id: int) -&gt; bool:\n    \"\"\"\n    Check if a state is a start state.\n    Args :\n        state_id: Integer index of the state.\n    Returns :\n        bool\n    \"\"\"\n    state = ctypes.c_size_t(state_id)\n    is_start = ctypes.c_size_t()\n\n    ret_code = lib.fst_is_start(self.ptr, state, ctypes.byref(is_start))\n    err_msg = \"Error checking if state is final\"\n    check_ffi_error(ret_code, err_msg)\n\n    return bool(is_start.value)\n</code></pre>"},{"location":"rustfst/fst/#rustfst.fst.Fst.input_symbols","title":"<code>input_symbols() -&gt; Optional[SymbolTable]</code>","text":"<p>Returns the Fst's input symbol table, or None if none is present. Returns :     The Fst's input symbol table, or None if none is present. See also: <code>output_symbols</code>.</p> Source code in <code>rustfst/fst/__init__.py</code> <pre><code>def input_symbols(self) -&gt; Optional[SymbolTable]:\n    \"\"\"\n    Returns the Fst's input symbol table, or None if none is present.\n    Returns :\n        The Fst's input symbol table, or None if none is present.\n    See also: `output_symbols`.\n    \"\"\"\n    if self._input_symbols:\n        return self._input_symbols\n\n    table = ctypes.pointer(ctypes.c_void_p())\n    ret_code = lib.fst_input_symbols(self.ptr, ctypes.byref(table))\n    err_msg = \"Error getting input symbols\"\n    check_ffi_error(ret_code, err_msg)\n\n    if table.contents:\n        return SymbolTable(ptr=table)\n    return None\n</code></pre>"},{"location":"rustfst/fst/#rustfst.fst.Fst.output_symbols","title":"<code>output_symbols() -&gt; Optional[SymbolTable]</code>","text":"<p>Returns the Fst's output symbol table, or None if none is present. Returns :     The Fst's output symbol table, or None if none is present. See also: <code>input_symbols</code>.</p> Source code in <code>rustfst/fst/__init__.py</code> <pre><code>def output_symbols(self) -&gt; Optional[SymbolTable]:\n    \"\"\"\n    Returns the Fst's output symbol table, or None if none is present.\n    Returns :\n        The Fst's output symbol table, or None if none is present.\n    See also: `input_symbols`.\n    \"\"\"\n    if self._output_symbols:\n        return self._output_symbols\n\n    table = ctypes.pointer(ctypes.c_void_p())\n\n    ret_code = lib.fst_output_symbols(self.ptr, ctypes.byref(table))\n    err_msg = \"Error getting output symbols\"\n    check_ffi_error(ret_code, err_msg)\n\n    if table.contents:\n        return SymbolTable(ptr=table)\n    return None\n</code></pre>"},{"location":"rustfst/fst/#rustfst.fst.Fst.set_input_symbols","title":"<code>set_input_symbols(syms: Optional[SymbolTable]) -&gt; Fst</code>","text":"<p>Sets the input symbol table. Passing None as a value will delete the input symbol table. Args:   syms: A SymbolTable. Returns:   self. See also: <code>set_output_symbols</code>.</p> Source code in <code>rustfst/fst/__init__.py</code> <pre><code>def set_input_symbols(self, syms: Optional[SymbolTable]) -&gt; Fst:\n    \"\"\"\n    Sets the input symbol table.\n    Passing None as a value will delete the input symbol table.\n    Args:\n      syms: A SymbolTable.\n    Returns:\n      self.\n    See also: `set_output_symbols`.\n    \"\"\"\n    if syms is None:\n        ret_code = lib.fst_unset_input_symbols(self.ptr)\n        err_msg = \"Error unsetting input symbols\"\n        check_ffi_error(ret_code, err_msg)\n        # detach symbol table from fst\n        self._input_symbols = None\n        return self\n\n    table = syms.ptr\n    ret_code = lib.fst_set_input_symbols(self.ptr, table)\n    err_msg = \"Error setting input symbols\"\n    check_ffi_error(ret_code, err_msg)\n\n    # attach symbol table to fst (prevent early gc of syms)\n    self._input_symbols = syms\n\n    return self\n</code></pre>"},{"location":"rustfst/fst/#rustfst.fst.Fst.set_output_symbols","title":"<code>set_output_symbols(syms: Optional[SymbolTable]) -&gt; Fst</code>","text":"<p>Sets the output symbol table. Passing None as a value will delete the output symbol table. Args:   syms: A SymbolTable. Returns:   self. See also: <code>set_input_symbols</code>.</p> Source code in <code>rustfst/fst/__init__.py</code> <pre><code>def set_output_symbols(self, syms: Optional[SymbolTable]) -&gt; Fst:\n    \"\"\"\n    Sets the output symbol table.\n    Passing None as a value will delete the output symbol table.\n    Args:\n      syms: A SymbolTable.\n    Returns:\n      self.\n    See also: `set_input_symbols`.\n    \"\"\"\n    if syms is None:\n        ret_code = lib.fst_unset_output_symbols(self.ptr)\n        err_msg = \"Error unsetting output symbols\"\n        check_ffi_error(ret_code, err_msg)\n        # detach symbol table from fst\n        self._output_symbols = None\n        return self\n\n    table = syms.ptr\n\n    ret_code = lib.fst_set_output_symbols(self.ptr, table)\n    err_msg = \"Error setting output symbols\"\n    check_ffi_error(ret_code, err_msg)\n\n    # attach symbol table to fst (prevent early gc of syms)\n    self._output_symbols = syms\n\n    return self\n</code></pre>"},{"location":"rustfst/fst/#rustfst.fst.Fst.remove_input_symbols","title":"<code>remove_input_symbols(symbols: list[int]) -&gt; Fst</code>","text":"<p>Parameters:</p> Name Type Description Default <code>symbols</code> <code>list[int]</code> <p>List[int]</p> required <p>Returns:   self.</p> Source code in <code>rustfst/fst/__init__.py</code> <pre><code>def remove_input_symbols(self, symbols: list[int]) -&gt; Fst:\n    \"\"\"\n    Args:\n      symbols: List[int]\n    Returns:\n      self.\n    \"\"\"\n    symbols_ptr = (ctypes.c_int * len(symbols))(*symbols)\n    symbols_len = ctypes.c_size_t(len(symbols))\n    ret_code = lib.fst_remove_input_symbols(self.ptr, symbols_ptr, symbols_len)\n    err_msg = \"Error during remove_input_symbols\"\n    check_ffi_error(ret_code, err_msg)\n\n    return self\n</code></pre>"},{"location":"rustfst/fst/#rustfst.fst.Fst.remove_output_symbols","title":"<code>remove_output_symbols(symbols: list[int]) -&gt; Fst</code>","text":"<p>Parameters:</p> Name Type Description Default <code>symbols</code> <code>list[int]</code> <p>List[int]</p> required <p>Returns:   self.</p> Source code in <code>rustfst/fst/__init__.py</code> <pre><code>def remove_output_symbols(self, symbols: list[int]) -&gt; Fst:\n    \"\"\"\n    Args:\n      symbols: List[int]\n    Returns:\n      self.\n    \"\"\"\n    symbols_ptr = (ctypes.c_int * len(symbols))(*symbols)\n    symbols_len = ctypes.c_size_t(len(symbols))\n    ret_code = lib.fst_remove_output_symbols(self.ptr, symbols_ptr, symbols_len)\n    err_msg = \"Error during remove_outout_symbols\"\n    check_ffi_error(ret_code, err_msg)\n\n    return self\n</code></pre>"},{"location":"rustfst/fst/#rustfst.fst.Fst.__eq__","title":"<code>__eq__(y: Fst)</code>","text":"<p>x.eq(y) &lt;==&gt; x==y</p> Source code in <code>rustfst/fst/__init__.py</code> <pre><code>def __eq__(self, y: Fst):\n    \"\"\"x.__eq__(y) &lt;==&gt; x==y\"\"\"\n    return self.equals(y)\n</code></pre>"},{"location":"rustfst/fst/#rustfst.fst-modules","title":"Modules","text":""},{"location":"rustfst/fst/#rustfst.fst.const_fst","title":"<code>const_fst</code>","text":""},{"location":"rustfst/fst/#rustfst.fst.const_fst-classes","title":"Classes","text":""},{"location":"rustfst/fst/#rustfst.fst.vector_fst","title":"<code>vector_fst</code>","text":""},{"location":"rustfst/fst/#rustfst.fst.vector_fst-classes","title":"Classes","text":""},{"location":"rustfst/fst/#rustfst.fst.vector_fst-functions","title":"Functions","text":""},{"location":"rustfst/fst/const_fst/","title":"const_fst","text":""},{"location":"rustfst/fst/const_fst/#rustfst.fst.const_fst-classes","title":"Classes","text":""},{"location":"rustfst/fst/const_fst/#rustfst.fst.const_fst.ConstFst","title":"<code>ConstFst</code>","text":"<p>               Bases: <code>Fst</code></p> Source code in <code>rustfst/fst/const_fst.py</code> <pre><code>class ConstFst(Fst):\n    def __init__(self, ptr=None):\n        if ptr:\n            self.ptr = ptr\n        else:\n            raise ValueError(\n                \"Const fst should be init with a pointer or loaded from a file\"\n            )\n        super().__init__(self.ptr)\n\n    def draw(\n        self,\n        filename: str,\n        isymbols: Optional[SymbolTable] = None,\n        osymbols: Optional[SymbolTable] = None,\n        drawing_config: DrawingConfig = DrawingConfig(),\n    ):\n        \"\"\"\n        Writes out the FST in Graphviz text format.\n        This method writes out the FST in the dot graph description language. The\n        graph can be rendered using the `dot` executable provided by Graphviz.\n        Args:\n          filename: The string location of the output dot/Graphviz file.\n          isymbols: An optional symbol table used to label input symbols.\n          osymbols: An optional symbol table used to label output symbols.\n          drawing_config: Drawing configuration to use.\n        See also: `text`.\n        \"\"\"\n\n        isymbols_ptr = isymbols.ptr if isymbols is not None else None\n        osymbols_ptr = osymbols.ptr if osymbols is not None else None\n\n        if drawing_config.width is None:\n            width = ctypes.c_float(-1.0)\n        else:\n            width = ctypes.c_float(drawing_config.width)\n\n        if drawing_config.height is None:\n            height = ctypes.c_float(-1.0)\n        else:\n            height = ctypes.c_float(drawing_config.height)\n\n        if drawing_config.ranksep is None:\n            ranksep = ctypes.c_float(-1.0)\n        else:\n            ranksep = ctypes.c_float(drawing_config.ranksep)\n\n        if drawing_config.nodesep is None:\n            nodesep = ctypes.c_float(-1.0)\n        else:\n            nodesep = ctypes.c_float(drawing_config.nodesep)\n\n        ret_code = lib.const_fst_draw(\n            self.ptr,\n            isymbols_ptr,\n            osymbols_ptr,\n            filename.encode(\"utf-8\"),\n            drawing_config.title.encode(\"utf-8\"),\n            ctypes.c_size_t(drawing_config.acceptor),\n            width,\n            height,\n            ctypes.c_size_t(drawing_config.portrait),\n            ctypes.c_size_t(drawing_config.vertical),\n            ranksep,\n            nodesep,\n            ctypes.c_size_t(drawing_config.fontsize),\n            ctypes.c_size_t(drawing_config.show_weight_one),\n            ctypes.c_size_t(drawing_config.print_weight),\n        )\n\n        err_msg = \"fst draw failed\"\n        check_ffi_error(ret_code, err_msg)\n\n    @classmethod\n    def read(cls, filename: Union[str, Path]) -&gt; ConstFst:\n        \"\"\"\n        Read a Fst at a given path.\n        Args:\n          filename: The string location of the input file.\n        Returns:\n          An FST.\n        Raises:\n          ValueError: Read failed.\n        \"\"\"\n        fst = ctypes.pointer(ctypes.c_void_p())\n        ret_code = lib.const_fst_from_path(\n            ctypes.byref(fst), str(filename).encode(\"utf-8\")\n        )\n        err_msg = f\"Read failed. file: {filename}\"\n        check_ffi_error(ret_code, err_msg)\n\n        return cls(ptr=fst)\n\n    @classmethod\n    def from_vector_fst(cls, fst: VectorFst) -&gt; ConstFst:\n        \"\"\"\n        Converts a given `VectorFst` to `ConstFst`\n        Args:\n          fst: The `VectorFst` that should be converted\n        Returns:\n          A `ConstFst`\n        Raises:\n          ValueError: Conversion failed\n        \"\"\"\n        const_fst = ctypes.pointer(ctypes.c_void_p())\n        ret_code = lib.const_fst_from_vec_fst(fst.ptr, ctypes.byref(const_fst))\n        err_msg = \"Failed to convert VectorFST to ConstFST\"\n        check_ffi_error(ret_code, err_msg)\n\n        return cls(ptr=const_fst)\n\n    def write(self, filename: Union[str, Path]):\n        \"\"\"\n        Serializes FST to a file.\n        This method writes the FST to a file in binary format.\n        Args:\n          filename: The string location of the output file.\n        Raises:\n          ValueError: Write failed.\n        \"\"\"\n        ret_code = lib.const_fst_write_file(self.ptr, str(filename).encode(\"utf-8\"))\n        err_msg = f\"Write failed. file: {filename}\"\n        check_ffi_error(ret_code, err_msg)\n\n    def equals(self, other: Fst) -&gt; bool:\n        \"\"\"\n        Check if this Fst is equal to the other\n        Args :\n            other: Fst instance\n        Returns:\n             bool\n        \"\"\"\n        is_equal = ctypes.c_size_t()\n\n        ret_code = lib.const_fst_equals(self.ptr, other.ptr, ctypes.byref(is_equal))\n        err_msg = \"Error checking equality\"\n        check_ffi_error(ret_code, err_msg)\n\n        return bool(is_equal.value)\n\n    def copy(self) -&gt; ConstFst:\n        \"\"\"\n        Returns :\n            Deepcopy of the Fst.\n        \"\"\"\n        cloned_fst = ctypes.c_size_t()\n        ret_code = lib.const_fst_copy(self.ptr, ctypes.byref(cloned_fst))\n        err_msg = \"Error copying fst\"\n        check_ffi_error(ret_code, err_msg)\n\n        return ConstFst(cloned_fst)\n\n    def __str__(self):\n        s = ctypes.c_void_p()\n        ret_code = lib.const_fst_display(self.ptr, ctypes.byref(s))\n        err_msg = \"Error displaying ConstFst\"\n        check_ffi_error(ret_code, err_msg)\n\n        return ctypes.string_at(s).decode(\"utf8\")\n</code></pre>"},{"location":"rustfst/fst/const_fst/#rustfst.fst.const_fst.ConstFst-functions","title":"Functions","text":""},{"location":"rustfst/fst/const_fst/#rustfst.fst.const_fst.ConstFst.draw","title":"<code>draw(filename: str, isymbols: Optional[SymbolTable] = None, osymbols: Optional[SymbolTable] = None, drawing_config: DrawingConfig = DrawingConfig())</code>","text":"<p>Writes out the FST in Graphviz text format. This method writes out the FST in the dot graph description language. The graph can be rendered using the <code>dot</code> executable provided by Graphviz. Args:   filename: The string location of the output dot/Graphviz file.   isymbols: An optional symbol table used to label input symbols.   osymbols: An optional symbol table used to label output symbols.   drawing_config: Drawing configuration to use. See also: <code>text</code>.</p> Source code in <code>rustfst/fst/const_fst.py</code> <pre><code>def draw(\n    self,\n    filename: str,\n    isymbols: Optional[SymbolTable] = None,\n    osymbols: Optional[SymbolTable] = None,\n    drawing_config: DrawingConfig = DrawingConfig(),\n):\n    \"\"\"\n    Writes out the FST in Graphviz text format.\n    This method writes out the FST in the dot graph description language. The\n    graph can be rendered using the `dot` executable provided by Graphviz.\n    Args:\n      filename: The string location of the output dot/Graphviz file.\n      isymbols: An optional symbol table used to label input symbols.\n      osymbols: An optional symbol table used to label output symbols.\n      drawing_config: Drawing configuration to use.\n    See also: `text`.\n    \"\"\"\n\n    isymbols_ptr = isymbols.ptr if isymbols is not None else None\n    osymbols_ptr = osymbols.ptr if osymbols is not None else None\n\n    if drawing_config.width is None:\n        width = ctypes.c_float(-1.0)\n    else:\n        width = ctypes.c_float(drawing_config.width)\n\n    if drawing_config.height is None:\n        height = ctypes.c_float(-1.0)\n    else:\n        height = ctypes.c_float(drawing_config.height)\n\n    if drawing_config.ranksep is None:\n        ranksep = ctypes.c_float(-1.0)\n    else:\n        ranksep = ctypes.c_float(drawing_config.ranksep)\n\n    if drawing_config.nodesep is None:\n        nodesep = ctypes.c_float(-1.0)\n    else:\n        nodesep = ctypes.c_float(drawing_config.nodesep)\n\n    ret_code = lib.const_fst_draw(\n        self.ptr,\n        isymbols_ptr,\n        osymbols_ptr,\n        filename.encode(\"utf-8\"),\n        drawing_config.title.encode(\"utf-8\"),\n        ctypes.c_size_t(drawing_config.acceptor),\n        width,\n        height,\n        ctypes.c_size_t(drawing_config.portrait),\n        ctypes.c_size_t(drawing_config.vertical),\n        ranksep,\n        nodesep,\n        ctypes.c_size_t(drawing_config.fontsize),\n        ctypes.c_size_t(drawing_config.show_weight_one),\n        ctypes.c_size_t(drawing_config.print_weight),\n    )\n\n    err_msg = \"fst draw failed\"\n    check_ffi_error(ret_code, err_msg)\n</code></pre>"},{"location":"rustfst/fst/const_fst/#rustfst.fst.const_fst.ConstFst.read","title":"<code>read(filename: Union[str, Path]) -&gt; ConstFst</code>  <code>classmethod</code>","text":"<p>Read a Fst at a given path. Args:   filename: The string location of the input file. Returns:   An FST. Raises:   ValueError: Read failed.</p> Source code in <code>rustfst/fst/const_fst.py</code> <pre><code>@classmethod\ndef read(cls, filename: Union[str, Path]) -&gt; ConstFst:\n    \"\"\"\n    Read a Fst at a given path.\n    Args:\n      filename: The string location of the input file.\n    Returns:\n      An FST.\n    Raises:\n      ValueError: Read failed.\n    \"\"\"\n    fst = ctypes.pointer(ctypes.c_void_p())\n    ret_code = lib.const_fst_from_path(\n        ctypes.byref(fst), str(filename).encode(\"utf-8\")\n    )\n    err_msg = f\"Read failed. file: {filename}\"\n    check_ffi_error(ret_code, err_msg)\n\n    return cls(ptr=fst)\n</code></pre>"},{"location":"rustfst/fst/const_fst/#rustfst.fst.const_fst.ConstFst.from_vector_fst","title":"<code>from_vector_fst(fst: VectorFst) -&gt; ConstFst</code>  <code>classmethod</code>","text":"<p>Converts a given <code>VectorFst</code> to <code>ConstFst</code> Args:   fst: The <code>VectorFst</code> that should be converted Returns:   A <code>ConstFst</code> Raises:   ValueError: Conversion failed</p> Source code in <code>rustfst/fst/const_fst.py</code> <pre><code>@classmethod\ndef from_vector_fst(cls, fst: VectorFst) -&gt; ConstFst:\n    \"\"\"\n    Converts a given `VectorFst` to `ConstFst`\n    Args:\n      fst: The `VectorFst` that should be converted\n    Returns:\n      A `ConstFst`\n    Raises:\n      ValueError: Conversion failed\n    \"\"\"\n    const_fst = ctypes.pointer(ctypes.c_void_p())\n    ret_code = lib.const_fst_from_vec_fst(fst.ptr, ctypes.byref(const_fst))\n    err_msg = \"Failed to convert VectorFST to ConstFST\"\n    check_ffi_error(ret_code, err_msg)\n\n    return cls(ptr=const_fst)\n</code></pre>"},{"location":"rustfst/fst/const_fst/#rustfst.fst.const_fst.ConstFst.write","title":"<code>write(filename: Union[str, Path])</code>","text":"<p>Serializes FST to a file. This method writes the FST to a file in binary format. Args:   filename: The string location of the output file. Raises:   ValueError: Write failed.</p> Source code in <code>rustfst/fst/const_fst.py</code> <pre><code>def write(self, filename: Union[str, Path]):\n    \"\"\"\n    Serializes FST to a file.\n    This method writes the FST to a file in binary format.\n    Args:\n      filename: The string location of the output file.\n    Raises:\n      ValueError: Write failed.\n    \"\"\"\n    ret_code = lib.const_fst_write_file(self.ptr, str(filename).encode(\"utf-8\"))\n    err_msg = f\"Write failed. file: {filename}\"\n    check_ffi_error(ret_code, err_msg)\n</code></pre>"},{"location":"rustfst/fst/const_fst/#rustfst.fst.const_fst.ConstFst.equals","title":"<code>equals(other: Fst) -&gt; bool</code>","text":"<p>Check if this Fst is equal to the other Args :     other: Fst instance Returns:      bool</p> Source code in <code>rustfst/fst/const_fst.py</code> <pre><code>def equals(self, other: Fst) -&gt; bool:\n    \"\"\"\n    Check if this Fst is equal to the other\n    Args :\n        other: Fst instance\n    Returns:\n         bool\n    \"\"\"\n    is_equal = ctypes.c_size_t()\n\n    ret_code = lib.const_fst_equals(self.ptr, other.ptr, ctypes.byref(is_equal))\n    err_msg = \"Error checking equality\"\n    check_ffi_error(ret_code, err_msg)\n\n    return bool(is_equal.value)\n</code></pre>"},{"location":"rustfst/fst/const_fst/#rustfst.fst.const_fst.ConstFst.copy","title":"<code>copy() -&gt; ConstFst</code>","text":"Returns <p>Deepcopy of the Fst.</p> Source code in <code>rustfst/fst/const_fst.py</code> <pre><code>def copy(self) -&gt; ConstFst:\n    \"\"\"\n    Returns :\n        Deepcopy of the Fst.\n    \"\"\"\n    cloned_fst = ctypes.c_size_t()\n    ret_code = lib.const_fst_copy(self.ptr, ctypes.byref(cloned_fst))\n    err_msg = \"Error copying fst\"\n    check_ffi_error(ret_code, err_msg)\n\n    return ConstFst(cloned_fst)\n</code></pre>"},{"location":"rustfst/fst/vector_fst/","title":"vector_fst","text":""},{"location":"rustfst/fst/vector_fst/#rustfst.fst.vector_fst-classes","title":"Classes","text":""},{"location":"rustfst/fst/vector_fst/#rustfst.fst.vector_fst.VectorFst","title":"<code>VectorFst</code>","text":"<p>               Bases: <code>Fst</code></p> Source code in <code>rustfst/fst/vector_fst.py</code> <pre><code>class VectorFst(Fst):\n    def __init__(self, ptr=None):\n        \"\"\"\n        Creates an empty VectorFst.\n        \"\"\"\n        self._input_symbols = None\n        self._output_symbols = None\n\n        if ptr:\n            self.ptr = ptr\n\n            # Check if isymt inside\n            isymt = ctypes.pointer(ctypes.c_void_p())\n            ret_code = lib.fst_input_symbols(self.ptr, ctypes.byref(isymt))\n            err_msg = \"Error getting input symbols\"\n            check_ffi_error(ret_code, err_msg)\n            if isymt.contents:\n                self._input_symbols = SymbolTable(ptr=isymt)\n\n            # Check if osymt inside\n            osymt = ctypes.pointer(ctypes.c_void_p())\n            ret_code = lib.fst_output_symbols(self.ptr, ctypes.byref(osymt))\n            err_msg = \"Error getting input symbols\"\n            check_ffi_error(ret_code, err_msg)\n            if osymt.contents:\n                self._output_symbols = SymbolTable(ptr=osymt)\n\n        else:\n            fst_ptr = ctypes.pointer(ctypes.c_void_p())\n            ret_code = lib.vec_fst_new(ctypes.byref(fst_ptr))\n\n            err_msg = \"Something went wrong when creating the Fst struct\"\n            check_ffi_error(ret_code, err_msg)\n            self.ptr = fst_ptr\n\n        super().__init__(self.ptr, self._input_symbols, self._output_symbols)\n\n    def add_tr(self, state: int, tr: Tr) -&gt; Fst:\n        \"\"\"\n        Adds a new tr to the FST and return self. Note the tr should be considered\n        consumed and is not safe to use it after.\n        Args:\n          state: The integer index of the source state.\n          tr: The tr to add.\n        Returns:\n          self.\n        Raises:\n          SnipsFstException: If State index out of range.\n        See also: `add_state`.\n        \"\"\"\n        ret_code = lib.vec_fst_add_tr(self.ptr, ctypes.c_size_t(state), tr.ptr)\n        err_msg = \"Error during `add_tr`\"\n        check_ffi_error(ret_code, err_msg)\n\n        return self\n\n    def add_state(self) -&gt; int:\n        \"\"\"\n        Adds a new state to the FST and returns the state ID.\n        Returns:\n          The integer index of the new state.\n        See also: `add_tr`, `set_start`, `set_final`.\n        \"\"\"\n        state_id = ctypes.c_size_t()\n\n        ret_code = lib.vec_fst_add_state(self.ptr, ctypes.byref(state_id))\n        err_msg = \"Error during `add_state`\"\n        check_ffi_error(ret_code, err_msg)\n\n        return state_id.value\n\n    def set_final(self, state: int, weight: Union[float, None] = None):\n        \"\"\"\n        Sets the final weight for a state.\n        Args:\n          state: The integer index of a state.\n          weight: A float indicating the desired final weight; if\n              omitted, it is set to semiring One.\n        Raises:\n          ValueError: State index out of range or Incompatible or invalid weight.\n        See also: `set_start`.\n        \"\"\"\n        if weight is None:\n            weight = weight_one()\n\n        cstate = ctypes.c_size_t(state)\n        cweight = ctypes.c_float(weight)\n\n        ret_code = lib.vec_fst_set_final(self.ptr, cstate, cweight)\n        err_msg = \"Error setting final state\"\n        check_ffi_error(ret_code, err_msg)\n\n    def unset_final(self, state: int):\n        \"\"\"\n        Unset the final weight of a state. As a result, the state is no longer final.\n        Args:\n            state: The integer index of a state\n        Raises:\n          ValueError: State index out of range.\n        \"\"\"\n        cstate = ctypes.c_size_t(state)\n        ret_code = lib.vec_fst_del_final_weight(self.ptr, cstate)\n        err_msg = \"Error unsetting final state\"\n        check_ffi_error(ret_code, err_msg)\n\n    def mutable_trs(self, state: int) -&gt; MutableTrsIterator:\n        \"\"\"\n        Returns a mutable iterator over trs leaving the specified state.\n        Args:\n          state: The source state ID.\n        Returns:\n          A MutableTrsIterator.\n        See also: `trs`, `states`.\n        \"\"\"\n        return MutableTrsIterator(self, state)\n\n    def delete_states(self):\n        \"\"\"\n        Delete all the states\n        \"\"\"\n        ret_code = lib.vec_fst_delete_states(self.ptr)\n        err_msg = \"Error deleting states\"\n        check_ffi_error(ret_code, err_msg)\n\n    def num_states(self) -&gt; int:\n        \"\"\"\n        Returns the number of states.\n        Returns:\n            Number of states present in the Fst.\n        \"\"\"\n        num_states = ctypes.c_size_t()\n        ret_code = lib.vec_fst_num_states(self.ptr, ctypes.byref(num_states))\n        err_msg = \"Error getting number of states\"\n        check_ffi_error(ret_code, err_msg)\n\n        return int(num_states.value)\n\n    def set_start(self, state: int):\n        \"\"\"\n        Sets a state to be the initial state state.\n        Args:\n          state: The integer index of a state.\n        Raises:\n          ValueError: If State index out of range.\n        See also: `set_final`.\n        \"\"\"\n        state_id = ctypes.c_size_t(state)\n        ret_code = lib.vec_fst_set_start(self.ptr, state_id)\n        err_msg = \"Error setting start state\"\n        check_ffi_error(ret_code, err_msg)\n\n    def states(self) -&gt; StateIterator:\n        \"\"\"\n        Returns an iterator over all states in the FST.\n        Returns:\n          A StateIterator object for the FST.\n        See also: `trs`, `mutable_trs`.\n        \"\"\"\n        return StateIterator(self)\n\n    def relabel_tables(\n        self,\n        *,\n        old_isymbols: Optional[SymbolTable] = None,\n        new_isymbols: SymbolTable,\n        attach_new_isymbols: bool = True,\n        old_osymbols: Optional[SymbolTable] = None,\n        new_osymbols: SymbolTable,\n        attach_new_osymbols: bool = True,\n    ) -&gt; VectorFst:\n        \"\"\"\n        Destructively relabel the Fst with new Symbol Tables.\n\n        Relabelling refers to the operation where all the labels of an Fst are mapped to the equivalent labels\n        of a new `SymbolTable`.\n        If the Fst has a label `1` corresponding to the symbol \"alpha\" in the current symbol table and \"alpha\"\n        is mapped to 4 in a new SymbolTable, then all the 1 are going to be mapped to 4.\n\n        Args:\n            old_isymbols: Input `SymbolTable` used to build the Fst. If `None`, uses the Input `SymbolTable` attached to the Fst.\n            new_isymbols: New Input `SymbolTable` to use.\n            attach_new_isymbols: Whether to attach the new Input `SymbolTable` to the Fst. If False, the resulting Fst won't contain any attached Input `SymbolTable`.\n            old_osymbols: Output `SymbolTable` used to build the Fst. If `None`, uses the Output `SymbolTable` attached to the Fst\n            new_osymbols: New Output `SymbolTable` to use.\n            attach_new_osymbols: Whether to attach the new Output `SymbolTable` to the Fst. If False, the resulting Fst won't contain any attached Output `SymbolTable`.\n\n        Returns:\n            self\n\n        \"\"\"\n        old_isymbols_ptr = old_isymbols.ptr if old_isymbols is not None else None\n        old_osymbols_ptr = old_osymbols.ptr if old_osymbols is not None else None\n\n        ret_code = lib.vec_fst_relabel_tables(\n            self.ptr,\n            old_isymbols_ptr,\n            new_isymbols.ptr,\n            ctypes.c_size_t(attach_new_isymbols),\n            old_osymbols_ptr,\n            new_osymbols.ptr,\n            ctypes.c_size_t(attach_new_osymbols),\n        )\n        err_msg = \"Relabel tables failed\"\n        check_ffi_error(ret_code, err_msg)\n\n        # Necessary because the symts are cached on the python side.\n        if attach_new_isymbols:\n            self._input_symbols = new_isymbols\n        else:\n            self._input_symbols = None\n\n        if attach_new_osymbols:\n            self._output_symbols = new_osymbols\n        else:\n            self._output_symbols = None\n\n        return self\n\n    def draw(\n        self,\n        filename: str,\n        isymbols: Optional[SymbolTable] = None,\n        osymbols: Optional[SymbolTable] = None,\n        drawing_config: DrawingConfig = DrawingConfig(),\n    ):\n        \"\"\"\n        Writes out the FST in Graphviz text format.\n        This method writes out the FST in the dot graph description language. The\n        graph can be rendered using the `dot` executable provided by Graphviz.\n        Args:\n          filename: The string location of the output dot/Graphviz file.\n          isymbols: An optional symbol table used to label input symbols.\n          osymbols: An optional symbol table used to label output symbols.\n          drawing_config: Drawing configuration to use.\n        See also: `text`.\n        \"\"\"\n\n        isymbols_ptr = isymbols.ptr if isymbols is not None else None\n        osymbols_ptr = osymbols.ptr if osymbols is not None else None\n\n        if drawing_config.width is None:\n            width = ctypes.c_float(-1.0)\n        else:\n            width = ctypes.c_float(drawing_config.width)\n\n        if drawing_config.height is None:\n            height = ctypes.c_float(-1.0)\n        else:\n            height = ctypes.c_float(drawing_config.height)\n\n        if drawing_config.ranksep is None:\n            ranksep = ctypes.c_float(-1.0)\n        else:\n            ranksep = ctypes.c_float(drawing_config.ranksep)\n\n        if drawing_config.nodesep is None:\n            nodesep = ctypes.c_float(-1.0)\n        else:\n            nodesep = ctypes.c_float(drawing_config.nodesep)\n\n        ret_code = lib.vec_fst_draw(\n            self.ptr,\n            isymbols_ptr,\n            osymbols_ptr,\n            filename.encode(\"utf-8\"),\n            drawing_config.title.encode(\"utf-8\"),\n            ctypes.c_size_t(drawing_config.acceptor),\n            width,\n            height,\n            ctypes.c_size_t(drawing_config.portrait),\n            ctypes.c_size_t(drawing_config.vertical),\n            ranksep,\n            nodesep,\n            ctypes.c_size_t(drawing_config.fontsize),\n            ctypes.c_size_t(drawing_config.show_weight_one),\n            ctypes.c_size_t(drawing_config.print_weight),\n        )\n\n        err_msg = \"fst draw failed\"\n        check_ffi_error(ret_code, err_msg)\n\n    @classmethod\n    def read(cls, filename: Union[str, Path]) -&gt; VectorFst:\n        \"\"\"\n        Read a Fst at a given path.\n        Args:\n          filename: The string location of the input file.\n        Returns:\n          An Fst.\n        Raises:\n          ValueError: Read failed.\n        \"\"\"\n        fst = ctypes.pointer(ctypes.c_void_p())\n        ret_code = lib.vec_fst_from_path(\n            ctypes.byref(fst), str(filename).encode(\"utf-8\")\n        )\n        err_msg = f\"Read failed. file: {filename}\"\n        check_ffi_error(ret_code, err_msg)\n\n        return cls(ptr=fst)\n\n    def write(self, filename: Union[str, Path]):\n        \"\"\"\n        Serializes FST to a file.\n        This method writes the FST to a file in vector binary format.\n        Args:\n          filename: The string location of the output file.\n        Raises:\n          ValueError: Write failed.\n        \"\"\"\n        ret_code = lib.vec_fst_write_file(self.ptr, str(filename).encode(\"utf-8\"))\n        err_msg = f\"Write failed. file: {filename}\"\n        check_ffi_error(ret_code, err_msg)\n\n    @classmethod\n    def from_bytes(cls, data: bytes) -&gt; VectorFst:\n        \"\"\"\n        Load a `VectorFst` from a sequence of bytes.\n        Args:\n            data: Sequence of bytes.\n\n        Returns:\n            Loaded `VectorFst`.\n        \"\"\"\n        fst_ptr = ctypes.pointer(ctypes.c_void_p())\n\n        # Define a temporary struct to hold the bytes array\n        class BytesArray(ctypes.Structure):\n            _fields_ = [(\"data_ptr\", ctypes.c_char_p), (\"size\", ctypes.c_size_t)]\n\n        c_bytes = BytesArray(data, len(data))\n\n        ret_code = lib.vec_fst_from_bytes(ctypes.byref(c_bytes), ctypes.byref(fst_ptr))\n        error_msg = \"`from_bytes` failed\"\n        check_ffi_error(ret_code, error_msg)\n\n        return VectorFst(ptr=fst_ptr)\n\n    def to_bytes(self) -&gt; bytes:\n        \"\"\"\n        Turns the `VectorFst` into bytes.\n        Returns:\n            Sequence of bytes.\n        \"\"\"\n\n        # Define a temporary struct to hold the bytes array\n        class BytesArray(ctypes.Structure):\n            _fields_ = [(\"data_ptr\", ctypes.c_void_p), (\"size\", ctypes.c_size_t)]\n\n        bytes_ptr = ctypes.pointer(BytesArray())\n\n        ret_code = lib.vec_fst_to_bytes(self.ptr, ctypes.byref(bytes_ptr))\n        error_msg = \"`to_bytes` failed\"\n        check_ffi_error(ret_code, error_msg)\n\n        return bytes(\n            [\n                ctypes.c_ubyte.from_address(bytes_ptr.contents.data_ptr + i).value\n                for i in range(bytes_ptr.contents.size)\n            ]\n        )\n\n    def equals(self, other: Fst) -&gt; bool:\n        \"\"\"\n        Check if this Fst is equal to the other.\n        Args:\n            other: Fst instance\n        Returns:\n             Whether both Fst are equals.\n        \"\"\"\n        is_equal = ctypes.c_size_t()\n\n        ret_code = lib.vec_fst_equals(self.ptr, other.ptr, ctypes.byref(is_equal))\n        err_msg = \"Error checking equality\"\n        check_ffi_error(ret_code, err_msg)\n\n        return bool(is_equal.value)\n\n    def copy(self) -&gt; VectorFst:\n        \"\"\"\n        Returns:\n            A copy of the Fst.\n        \"\"\"\n        cloned_fst = ctypes.pointer(ctypes.c_void_p())\n        ret_code = lib.vec_fst_copy(self.ptr, ctypes.byref(cloned_fst))\n        err_msg = \"Error copying fst\"\n        check_ffi_error(ret_code, err_msg)\n\n        return VectorFst(cloned_fst)\n\n    def compose(\n        self, other: VectorFst, config: Union[ComposeConfig, None] = None\n    ) -&gt; VectorFst:\n        \"\"\"\n        Compute composition of this Fst with another Fst, returning\n        the resulting Fst.\n        Args:\n            other: Fst to compose with.\n            config: Config parameters of the composition.\n        Returns:\n            The composed Fst.\n        \"\"\"\n\n        from rustfst.algorithms.compose import compose, compose_with_config\n\n        if config:\n            return compose_with_config(self, other, config)\n        return compose(self, other)\n\n    def concat(self, other: VectorFst) -&gt; VectorFst:\n        \"\"\"\n        Compute Fst Concatenation of this Fst with another Fst, returning the\n        resulting Fst.\n        Args:\n            other: Fst to concatenate with.\n\n        Returns:\n            The concatenated Fst.\n\n        \"\"\"\n        from rustfst.algorithms.concat import concat\n\n        return concat(self, other)\n\n    def connect(self) -&gt; VectorFst:\n        \"\"\"\n        This operation trims an Fst in-place, removing states and trs that are\n        not on successful paths.\n\n        Examples :\n\n        - Input\n\n        ![connect_in](https://raw.githubusercontent.com/Garvys/rustfst-images-doc/master/images/connect_in.svg?sanitize=true)\n\n        - Output\n\n        ![connect_out](https://raw.githubusercontent.com/Garvys/rustfst-images-doc/master/images/connect_out.svg?sanitize=true)\n\n        Returns:\n            self\n        \"\"\"\n        from rustfst.algorithms.connect import connect\n\n        return connect(self)\n\n    def top_sort(self) -&gt; VectorFst:\n        \"\"\"\n        This operation topologically sorts its input. When sorted, all transitions are from\n        lower to higher state IDs.\n\n        Examples :\n\n        - Input\n\n        ![topsort_in](https://raw.githubusercontent.com/Garvys/rustfst-images-doc/master/images/topsort_in.svg?sanitize=true)\n\n        - Output\n\n        ![topsort_out](https://raw.githubusercontent.com/Garvys/rustfst-images-doc/master/images/topsort_out.svg?sanitize=true)\n\n        Returns:\n            Equivalent top sorted Fst. Modification also happens in-place.\n        \"\"\"\n        from rustfst.algorithms.top_sort import top_sort\n\n        return top_sort(self)\n\n    def determinize(self, config: Union[DeterminizeConfig, None] = None) -&gt; VectorFst:\n        \"\"\"\n        Make an Fst deterministic\n        Args:\n            config: Configuration for the determinization operation.\n        Returns:\n            The resulting Fst.\n        \"\"\"\n        from rustfst.algorithms.determinize import determinize, determinize_with_config\n\n        if config:\n            return determinize_with_config(self, config)\n        return determinize(self)\n\n    def minimize(self, config: Union[MinimizeConfig, None] = None) -&gt; VectorFst:\n        \"\"\"\n        Minimize an FST in place\n        Args:\n          config: Configuration for the minimization operation.\n        Returns:\n          self\n        \"\"\"\n        from rustfst.algorithms.minimize import minimize, minimize_with_config\n\n        if config:\n            return minimize_with_config(self, config)\n        return minimize(self)\n\n    def project(self, proj_type: Union[ProjectType, None] = None) -&gt; VectorFst:\n        \"\"\"\n        Convert a Fst to an acceptor using input or output labels.\n        Args:\n            proj_type: Whether to replace input labels or output labels.\n        Returns:\n            self\n        \"\"\"\n        from rustfst.algorithms.project import project, ProjectType  # noqa: W0621\n\n        if proj_type:\n            return project(self, proj_type)\n        proj_type = ProjectType.PROJECT_INPUT\n        return project(self, proj_type)\n\n    def replace(\n        self,\n        root_label: int,\n        fst_list: List[Tuple[int, VectorFst]],\n        epsilon_on_replace: bool = False,\n    ) -&gt; VectorFst:\n        \"\"\"Recursively replaces trs in the root FSTs with other FSTs.\n\n        Replace supports replacement of trs in one Fst with another\n        FST. This replacement is recursive. Replace takes an array of\n        FST(s). The FST on which this method is called represents the\n        root (or topology) machine. The root FST refers to other FSTs\n        by recursively replacing trs labeled as non-terminals with the\n        matching non-terminal FST. Currently Replace uses the output\n        symbols of the trs to determine whether the transition is a\n        non-terminal transition or not. A non-terminal can be any\n        label that is not a non-zero terminal label in the output\n        alphabet.\n\n        Note that input argument is a vector of pairs. These\n        correspond to the tuple of non-terminal Label and\n        corresponding FST.\n\n        Examples:\n\n        - Root Fst :\n\n        ![replace_in_1](https://raw.githubusercontent.com/Garvys/rustfst-images-doc/master/images/replace_in_1.svg?sanitize=true)\n\n        - Fst for non-terminal #NAME :\n\n        ![replace_in_2](https://raw.githubusercontent.com/Garvys/rustfst-images-doc/master/images/replace_in_2.svg?sanitize=true)\n\n        - Fst for non-terminal #FIRSTNAME :\n\n        ![replace_in_3](https://raw.githubusercontent.com/Garvys/rustfst-images-doc/master/images/replace_in_3.svg?sanitize=true)\n\n        - Fst for non-terminal #LASTNAME :\n\n        ![replace_in_4](https://raw.githubusercontent.com/Garvys/rustfst-images-doc/master/images/replace_in_4.svg?sanitize=true)\n\n        - Output :\n\n        ![replace_out](https://raw.githubusercontent.com/Garvys/rustfst-images-doc/master/images/replace_out.svg?sanitize=true)\n\n        Args:\n            root_label: Label for self\n            fst_list: Other FSTs\n            epsilon_on_replace:\n\n        Returns:\n            The resulting Fst.\n\n        \"\"\"\n        from rustfst.algorithms.replace import replace\n\n        complete_fst_list = [(root_label, self)] + fst_list\n        return replace(root_label, complete_fst_list, epsilon_on_replace)\n\n    def reverse(self) -&gt; VectorFst:\n        \"\"\"\n        Reverse an Fst, returning a new Fst which accepts\n        the same language in reverse order.\n\n        Returns:\n          Newly created, reversed Fst.\n        \"\"\"\n        from rustfst.algorithms.reverse import reverse\n\n        return reverse(self)\n\n    def rm_epsilon(self) -&gt; VectorFst:\n        \"\"\"\n        Remove epsilon transitions in-place.\n        Returns:\n          self: Same FST, modified in place\n        \"\"\"\n        from rustfst.algorithms.rm_epsilon import rm_epsilon\n\n        return rm_epsilon(self)\n\n    def shortest_path(\n        self, config: Union[ShortestPathConfig, None] = None\n    ) -&gt; VectorFst:\n        \"\"\"\n        Construct a FST containing the shortest path of the input FST\n        Args:\n          config: Configuration for shortest-path operation.\n        Returns:\n          Newly-created FST containing only the shortest path of the input FST.\n        \"\"\"\n        from rustfst.algorithms.shortest_path import (\n            shortestpath,\n            shortestpath_with_config,\n        )\n\n        if config:\n            return shortestpath_with_config(self, config)\n        return shortestpath(self)\n\n    def union(self, other_fst: VectorFst) -&gt; VectorFst:\n        \"\"\"\n        Performs the union of two wFSTs. If A transduces string `x` to `y` with weight `a`\n        and `B` transduces string `w` to `v` with weight `b`, then their union transduces `x` to `y`\n        with weight `a` and `w` to `v` with weight `b`.\n\n        Examples:\n        - Input Fst 1:\n\n        ![union_in_1](https://raw.githubusercontent.com/Garvys/rustfst-images-doc/master/images/union_in_1.svg?sanitize=true)\n\n        - Input Fst 2:\n\n        ![union_in_2](https://raw.githubusercontent.com/Garvys/rustfst-images-doc/master/images/union_in_2.svg?sanitize=true)\n\n        - Union:\n\n        ![union_out](https://raw.githubusercontent.com/Garvys/rustfst-images-doc/master/images/union_out.svg?sanitize=true)\n\n        Args:\n            other_fst: Fst to perform union with this one.\n        Returns:\n             The resulting newly-created Fst.\n\n        \"\"\"\n        from rustfst.algorithms.union import union\n\n        return union(self, other_fst)\n\n    def optimize(self) -&gt; VectorFst:\n        \"\"\"\n        Optimize an FST in-place.\n        Returns:\n          self\n        \"\"\"\n        from rustfst.algorithms.optimize import optimize\n\n        return optimize(self)\n\n    def optimize_in_log(self) -&gt; VectorFst:\n        \"\"\"\n        Optimize an fst in-place in the log semiring.\n        Returns:\n          self\n        \"\"\"\n        from rustfst.algorithms.optimize import optimize_in_log\n\n        return optimize_in_log(self)\n\n    def tr_sort(self, ilabel_cmp: bool = True) -&gt; VectorFst:\n        \"\"\"Sort trs for an FST in-place according to their input or\n        output label.\n\n        This is often necessary for composition to work properly.  It\n        corresponds to `ArcSort` in OpenFST.\n\n        Args:\n          ilabel_cmp: Sort on input labels if `True`, output labels\n                      if `False`.\n        Returns:\n          self\n        \"\"\"\n        from rustfst.algorithms.tr_sort import tr_sort\n\n        return tr_sort(self, ilabel_cmp)\n\n    def tr_unique(self) -&gt; VectorFst:\n        \"\"\"Modify an FST in-place, keeping a single instance of trs\n        leaving the same state, going to the same state and with the\n        same input labels, output labels and weight.\n\n        Returns:\n          self\n        \"\"\"\n        from rustfst.algorithms.tr_unique import tr_unique\n\n        return tr_unique(self)\n\n    def isomorphic(self, other: VectorFst) -&gt; bool:\n        \"\"\"\n        Check if this Fst is isomorphic with another\n        Args:\n            other: Other Fst.\n        Returns:\n            Whether both Fsts are equal.\n        \"\"\"\n        from rustfst.algorithms.isomorphic import isomorphic\n\n        return isomorphic(self, other)\n\n    def invert(self) -&gt; VectorFst:\n        \"\"\"\n        Invert the transduction corresponding to an FST by exchanging the\n        FST's input and output labels in-place.\n\n        Returns:\n           self\n        \"\"\"\n        from rustfst.algorithms.inversion import invert\n\n        return invert(self)\n\n    def __add__(self, other: VectorFst) -&gt; VectorFst:\n        \"\"\"\n        `fst_1 + fst_2` is a shortcut to perform the concatenation of `fst_1` and `fst_2`.\n        Args:\n            other: VectorFst to concatenate after the current Fst.\n\n        Returns:\n            The concatenated Fst.\n        \"\"\"\n        x = self.copy()\n\n        return x.concat(other)\n\n    def __mul__(self, other: VectorFst) -&gt; VectorFst:\n        \"\"\"\n        `fst_1 * fst_2` is a shortcut to perform the composition of `fst_1` and `fst_2`.\n        Args:\n            other: VectorFst to compose with.\n\n        Returns:\n            The composed Fst.\n\n        \"\"\"\n        return self.compose(other)\n\n    def __or__(self, other: VectorFst) -&gt; VectorFst:\n        \"\"\"\n        `fst_1 | fst_2` is a shortcut to perform the union of `fst_1` and `fst_2`.\n        Args:\n            other: VectorFst to perform the union with.\n\n        Returns:\n            The resulting Fst.\n        \"\"\"\n        x = self.copy()\n\n        return x.union(other)\n\n    def __str__(self):\n        s = ctypes.c_void_p()\n        ret_code = lib.vec_fst_display(self.ptr, ctypes.byref(s))\n        err_msg = \"Error displaying VectorFst\"\n        check_ffi_error(ret_code, err_msg)\n\n        return ctypes.string_at(s).decode(\"utf8\")\n\n    def string_paths(self) -&gt; StringPathsIterator:\n        \"\"\"Return an iterator over input/output label sequences in\n        this FST, *in no particular order*.\n\n        Note that this does not return the best path first.  If you\n        want to do this, you will have to first apply\n        `shortest_path`.\n\n        Returns:\n          A iterator over the paths through this FST.\n        \"\"\"\n        return StringPathsIterator(self)\n</code></pre>"},{"location":"rustfst/fst/vector_fst/#rustfst.fst.vector_fst.VectorFst-functions","title":"Functions","text":""},{"location":"rustfst/fst/vector_fst/#rustfst.fst.vector_fst.VectorFst.__init__","title":"<code>__init__(ptr=None)</code>","text":"<p>Creates an empty VectorFst.</p> Source code in <code>rustfst/fst/vector_fst.py</code> <pre><code>def __init__(self, ptr=None):\n    \"\"\"\n    Creates an empty VectorFst.\n    \"\"\"\n    self._input_symbols = None\n    self._output_symbols = None\n\n    if ptr:\n        self.ptr = ptr\n\n        # Check if isymt inside\n        isymt = ctypes.pointer(ctypes.c_void_p())\n        ret_code = lib.fst_input_symbols(self.ptr, ctypes.byref(isymt))\n        err_msg = \"Error getting input symbols\"\n        check_ffi_error(ret_code, err_msg)\n        if isymt.contents:\n            self._input_symbols = SymbolTable(ptr=isymt)\n\n        # Check if osymt inside\n        osymt = ctypes.pointer(ctypes.c_void_p())\n        ret_code = lib.fst_output_symbols(self.ptr, ctypes.byref(osymt))\n        err_msg = \"Error getting input symbols\"\n        check_ffi_error(ret_code, err_msg)\n        if osymt.contents:\n            self._output_symbols = SymbolTable(ptr=osymt)\n\n    else:\n        fst_ptr = ctypes.pointer(ctypes.c_void_p())\n        ret_code = lib.vec_fst_new(ctypes.byref(fst_ptr))\n\n        err_msg = \"Something went wrong when creating the Fst struct\"\n        check_ffi_error(ret_code, err_msg)\n        self.ptr = fst_ptr\n\n    super().__init__(self.ptr, self._input_symbols, self._output_symbols)\n</code></pre>"},{"location":"rustfst/fst/vector_fst/#rustfst.fst.vector_fst.VectorFst.add_tr","title":"<code>add_tr(state: int, tr: Tr) -&gt; Fst</code>","text":"<p>Adds a new tr to the FST and return self. Note the tr should be considered consumed and is not safe to use it after. Args:   state: The integer index of the source state.   tr: The tr to add. Returns:   self. Raises:   SnipsFstException: If State index out of range. See also: <code>add_state</code>.</p> Source code in <code>rustfst/fst/vector_fst.py</code> <pre><code>def add_tr(self, state: int, tr: Tr) -&gt; Fst:\n    \"\"\"\n    Adds a new tr to the FST and return self. Note the tr should be considered\n    consumed and is not safe to use it after.\n    Args:\n      state: The integer index of the source state.\n      tr: The tr to add.\n    Returns:\n      self.\n    Raises:\n      SnipsFstException: If State index out of range.\n    See also: `add_state`.\n    \"\"\"\n    ret_code = lib.vec_fst_add_tr(self.ptr, ctypes.c_size_t(state), tr.ptr)\n    err_msg = \"Error during `add_tr`\"\n    check_ffi_error(ret_code, err_msg)\n\n    return self\n</code></pre>"},{"location":"rustfst/fst/vector_fst/#rustfst.fst.vector_fst.VectorFst.add_state","title":"<code>add_state() -&gt; int</code>","text":"<p>Adds a new state to the FST and returns the state ID. Returns:   The integer index of the new state. See also: <code>add_tr</code>, <code>set_start</code>, <code>set_final</code>.</p> Source code in <code>rustfst/fst/vector_fst.py</code> <pre><code>def add_state(self) -&gt; int:\n    \"\"\"\n    Adds a new state to the FST and returns the state ID.\n    Returns:\n      The integer index of the new state.\n    See also: `add_tr`, `set_start`, `set_final`.\n    \"\"\"\n    state_id = ctypes.c_size_t()\n\n    ret_code = lib.vec_fst_add_state(self.ptr, ctypes.byref(state_id))\n    err_msg = \"Error during `add_state`\"\n    check_ffi_error(ret_code, err_msg)\n\n    return state_id.value\n</code></pre>"},{"location":"rustfst/fst/vector_fst/#rustfst.fst.vector_fst.VectorFst.set_final","title":"<code>set_final(state: int, weight: Union[float, None] = None)</code>","text":"<p>Sets the final weight for a state. Args:   state: The integer index of a state.   weight: A float indicating the desired final weight; if       omitted, it is set to semiring One. Raises:   ValueError: State index out of range or Incompatible or invalid weight. See also: <code>set_start</code>.</p> Source code in <code>rustfst/fst/vector_fst.py</code> <pre><code>def set_final(self, state: int, weight: Union[float, None] = None):\n    \"\"\"\n    Sets the final weight for a state.\n    Args:\n      state: The integer index of a state.\n      weight: A float indicating the desired final weight; if\n          omitted, it is set to semiring One.\n    Raises:\n      ValueError: State index out of range or Incompatible or invalid weight.\n    See also: `set_start`.\n    \"\"\"\n    if weight is None:\n        weight = weight_one()\n\n    cstate = ctypes.c_size_t(state)\n    cweight = ctypes.c_float(weight)\n\n    ret_code = lib.vec_fst_set_final(self.ptr, cstate, cweight)\n    err_msg = \"Error setting final state\"\n    check_ffi_error(ret_code, err_msg)\n</code></pre>"},{"location":"rustfst/fst/vector_fst/#rustfst.fst.vector_fst.VectorFst.unset_final","title":"<code>unset_final(state: int)</code>","text":"<p>Unset the final weight of a state. As a result, the state is no longer final. Args:     state: The integer index of a state Raises:   ValueError: State index out of range.</p> Source code in <code>rustfst/fst/vector_fst.py</code> <pre><code>def unset_final(self, state: int):\n    \"\"\"\n    Unset the final weight of a state. As a result, the state is no longer final.\n    Args:\n        state: The integer index of a state\n    Raises:\n      ValueError: State index out of range.\n    \"\"\"\n    cstate = ctypes.c_size_t(state)\n    ret_code = lib.vec_fst_del_final_weight(self.ptr, cstate)\n    err_msg = \"Error unsetting final state\"\n    check_ffi_error(ret_code, err_msg)\n</code></pre>"},{"location":"rustfst/fst/vector_fst/#rustfst.fst.vector_fst.VectorFst.mutable_trs","title":"<code>mutable_trs(state: int) -&gt; MutableTrsIterator</code>","text":"<p>Returns a mutable iterator over trs leaving the specified state. Args:   state: The source state ID. Returns:   A MutableTrsIterator. See also: <code>trs</code>, <code>states</code>.</p> Source code in <code>rustfst/fst/vector_fst.py</code> <pre><code>def mutable_trs(self, state: int) -&gt; MutableTrsIterator:\n    \"\"\"\n    Returns a mutable iterator over trs leaving the specified state.\n    Args:\n      state: The source state ID.\n    Returns:\n      A MutableTrsIterator.\n    See also: `trs`, `states`.\n    \"\"\"\n    return MutableTrsIterator(self, state)\n</code></pre>"},{"location":"rustfst/fst/vector_fst/#rustfst.fst.vector_fst.VectorFst.delete_states","title":"<code>delete_states()</code>","text":"<p>Delete all the states</p> Source code in <code>rustfst/fst/vector_fst.py</code> <pre><code>def delete_states(self):\n    \"\"\"\n    Delete all the states\n    \"\"\"\n    ret_code = lib.vec_fst_delete_states(self.ptr)\n    err_msg = \"Error deleting states\"\n    check_ffi_error(ret_code, err_msg)\n</code></pre>"},{"location":"rustfst/fst/vector_fst/#rustfst.fst.vector_fst.VectorFst.num_states","title":"<code>num_states() -&gt; int</code>","text":"<p>Returns the number of states. Returns:     Number of states present in the Fst.</p> Source code in <code>rustfst/fst/vector_fst.py</code> <pre><code>def num_states(self) -&gt; int:\n    \"\"\"\n    Returns the number of states.\n    Returns:\n        Number of states present in the Fst.\n    \"\"\"\n    num_states = ctypes.c_size_t()\n    ret_code = lib.vec_fst_num_states(self.ptr, ctypes.byref(num_states))\n    err_msg = \"Error getting number of states\"\n    check_ffi_error(ret_code, err_msg)\n\n    return int(num_states.value)\n</code></pre>"},{"location":"rustfst/fst/vector_fst/#rustfst.fst.vector_fst.VectorFst.set_start","title":"<code>set_start(state: int)</code>","text":"<p>Sets a state to be the initial state state. Args:   state: The integer index of a state. Raises:   ValueError: If State index out of range. See also: <code>set_final</code>.</p> Source code in <code>rustfst/fst/vector_fst.py</code> <pre><code>def set_start(self, state: int):\n    \"\"\"\n    Sets a state to be the initial state state.\n    Args:\n      state: The integer index of a state.\n    Raises:\n      ValueError: If State index out of range.\n    See also: `set_final`.\n    \"\"\"\n    state_id = ctypes.c_size_t(state)\n    ret_code = lib.vec_fst_set_start(self.ptr, state_id)\n    err_msg = \"Error setting start state\"\n    check_ffi_error(ret_code, err_msg)\n</code></pre>"},{"location":"rustfst/fst/vector_fst/#rustfst.fst.vector_fst.VectorFst.states","title":"<code>states() -&gt; StateIterator</code>","text":"<p>Returns an iterator over all states in the FST. Returns:   A StateIterator object for the FST. See also: <code>trs</code>, <code>mutable_trs</code>.</p> Source code in <code>rustfst/fst/vector_fst.py</code> <pre><code>def states(self) -&gt; StateIterator:\n    \"\"\"\n    Returns an iterator over all states in the FST.\n    Returns:\n      A StateIterator object for the FST.\n    See also: `trs`, `mutable_trs`.\n    \"\"\"\n    return StateIterator(self)\n</code></pre>"},{"location":"rustfst/fst/vector_fst/#rustfst.fst.vector_fst.VectorFst.relabel_tables","title":"<code>relabel_tables(*, old_isymbols: Optional[SymbolTable] = None, new_isymbols: SymbolTable, attach_new_isymbols: bool = True, old_osymbols: Optional[SymbolTable] = None, new_osymbols: SymbolTable, attach_new_osymbols: bool = True) -&gt; VectorFst</code>","text":"<p>Destructively relabel the Fst with new Symbol Tables.</p> <p>Relabelling refers to the operation where all the labels of an Fst are mapped to the equivalent labels of a new <code>SymbolTable</code>. If the Fst has a label <code>1</code> corresponding to the symbol \"alpha\" in the current symbol table and \"alpha\" is mapped to 4 in a new SymbolTable, then all the 1 are going to be mapped to 4.</p> <p>Parameters:</p> Name Type Description Default <code>old_isymbols</code> <code>Optional[SymbolTable]</code> <p>Input <code>SymbolTable</code> used to build the Fst. If <code>None</code>, uses the Input <code>SymbolTable</code> attached to the Fst.</p> <code>None</code> <code>new_isymbols</code> <code>SymbolTable</code> <p>New Input <code>SymbolTable</code> to use.</p> required <code>attach_new_isymbols</code> <code>bool</code> <p>Whether to attach the new Input <code>SymbolTable</code> to the Fst. If False, the resulting Fst won't contain any attached Input <code>SymbolTable</code>.</p> <code>True</code> <code>old_osymbols</code> <code>Optional[SymbolTable]</code> <p>Output <code>SymbolTable</code> used to build the Fst. If <code>None</code>, uses the Output <code>SymbolTable</code> attached to the Fst</p> <code>None</code> <code>new_osymbols</code> <code>SymbolTable</code> <p>New Output <code>SymbolTable</code> to use.</p> required <code>attach_new_osymbols</code> <code>bool</code> <p>Whether to attach the new Output <code>SymbolTable</code> to the Fst. If False, the resulting Fst won't contain any attached Output <code>SymbolTable</code>.</p> <code>True</code> <p>Returns:</p> Type Description <code>VectorFst</code> <p>self</p> Source code in <code>rustfst/fst/vector_fst.py</code> <pre><code>def relabel_tables(\n    self,\n    *,\n    old_isymbols: Optional[SymbolTable] = None,\n    new_isymbols: SymbolTable,\n    attach_new_isymbols: bool = True,\n    old_osymbols: Optional[SymbolTable] = None,\n    new_osymbols: SymbolTable,\n    attach_new_osymbols: bool = True,\n) -&gt; VectorFst:\n    \"\"\"\n    Destructively relabel the Fst with new Symbol Tables.\n\n    Relabelling refers to the operation where all the labels of an Fst are mapped to the equivalent labels\n    of a new `SymbolTable`.\n    If the Fst has a label `1` corresponding to the symbol \"alpha\" in the current symbol table and \"alpha\"\n    is mapped to 4 in a new SymbolTable, then all the 1 are going to be mapped to 4.\n\n    Args:\n        old_isymbols: Input `SymbolTable` used to build the Fst. If `None`, uses the Input `SymbolTable` attached to the Fst.\n        new_isymbols: New Input `SymbolTable` to use.\n        attach_new_isymbols: Whether to attach the new Input `SymbolTable` to the Fst. If False, the resulting Fst won't contain any attached Input `SymbolTable`.\n        old_osymbols: Output `SymbolTable` used to build the Fst. If `None`, uses the Output `SymbolTable` attached to the Fst\n        new_osymbols: New Output `SymbolTable` to use.\n        attach_new_osymbols: Whether to attach the new Output `SymbolTable` to the Fst. If False, the resulting Fst won't contain any attached Output `SymbolTable`.\n\n    Returns:\n        self\n\n    \"\"\"\n    old_isymbols_ptr = old_isymbols.ptr if old_isymbols is not None else None\n    old_osymbols_ptr = old_osymbols.ptr if old_osymbols is not None else None\n\n    ret_code = lib.vec_fst_relabel_tables(\n        self.ptr,\n        old_isymbols_ptr,\n        new_isymbols.ptr,\n        ctypes.c_size_t(attach_new_isymbols),\n        old_osymbols_ptr,\n        new_osymbols.ptr,\n        ctypes.c_size_t(attach_new_osymbols),\n    )\n    err_msg = \"Relabel tables failed\"\n    check_ffi_error(ret_code, err_msg)\n\n    # Necessary because the symts are cached on the python side.\n    if attach_new_isymbols:\n        self._input_symbols = new_isymbols\n    else:\n        self._input_symbols = None\n\n    if attach_new_osymbols:\n        self._output_symbols = new_osymbols\n    else:\n        self._output_symbols = None\n\n    return self\n</code></pre>"},{"location":"rustfst/fst/vector_fst/#rustfst.fst.vector_fst.VectorFst.draw","title":"<code>draw(filename: str, isymbols: Optional[SymbolTable] = None, osymbols: Optional[SymbolTable] = None, drawing_config: DrawingConfig = DrawingConfig())</code>","text":"<p>Writes out the FST in Graphviz text format. This method writes out the FST in the dot graph description language. The graph can be rendered using the <code>dot</code> executable provided by Graphviz. Args:   filename: The string location of the output dot/Graphviz file.   isymbols: An optional symbol table used to label input symbols.   osymbols: An optional symbol table used to label output symbols.   drawing_config: Drawing configuration to use. See also: <code>text</code>.</p> Source code in <code>rustfst/fst/vector_fst.py</code> <pre><code>def draw(\n    self,\n    filename: str,\n    isymbols: Optional[SymbolTable] = None,\n    osymbols: Optional[SymbolTable] = None,\n    drawing_config: DrawingConfig = DrawingConfig(),\n):\n    \"\"\"\n    Writes out the FST in Graphviz text format.\n    This method writes out the FST in the dot graph description language. The\n    graph can be rendered using the `dot` executable provided by Graphviz.\n    Args:\n      filename: The string location of the output dot/Graphviz file.\n      isymbols: An optional symbol table used to label input symbols.\n      osymbols: An optional symbol table used to label output symbols.\n      drawing_config: Drawing configuration to use.\n    See also: `text`.\n    \"\"\"\n\n    isymbols_ptr = isymbols.ptr if isymbols is not None else None\n    osymbols_ptr = osymbols.ptr if osymbols is not None else None\n\n    if drawing_config.width is None:\n        width = ctypes.c_float(-1.0)\n    else:\n        width = ctypes.c_float(drawing_config.width)\n\n    if drawing_config.height is None:\n        height = ctypes.c_float(-1.0)\n    else:\n        height = ctypes.c_float(drawing_config.height)\n\n    if drawing_config.ranksep is None:\n        ranksep = ctypes.c_float(-1.0)\n    else:\n        ranksep = ctypes.c_float(drawing_config.ranksep)\n\n    if drawing_config.nodesep is None:\n        nodesep = ctypes.c_float(-1.0)\n    else:\n        nodesep = ctypes.c_float(drawing_config.nodesep)\n\n    ret_code = lib.vec_fst_draw(\n        self.ptr,\n        isymbols_ptr,\n        osymbols_ptr,\n        filename.encode(\"utf-8\"),\n        drawing_config.title.encode(\"utf-8\"),\n        ctypes.c_size_t(drawing_config.acceptor),\n        width,\n        height,\n        ctypes.c_size_t(drawing_config.portrait),\n        ctypes.c_size_t(drawing_config.vertical),\n        ranksep,\n        nodesep,\n        ctypes.c_size_t(drawing_config.fontsize),\n        ctypes.c_size_t(drawing_config.show_weight_one),\n        ctypes.c_size_t(drawing_config.print_weight),\n    )\n\n    err_msg = \"fst draw failed\"\n    check_ffi_error(ret_code, err_msg)\n</code></pre>"},{"location":"rustfst/fst/vector_fst/#rustfst.fst.vector_fst.VectorFst.read","title":"<code>read(filename: Union[str, Path]) -&gt; VectorFst</code>  <code>classmethod</code>","text":"<p>Read a Fst at a given path. Args:   filename: The string location of the input file. Returns:   An Fst. Raises:   ValueError: Read failed.</p> Source code in <code>rustfst/fst/vector_fst.py</code> <pre><code>@classmethod\ndef read(cls, filename: Union[str, Path]) -&gt; VectorFst:\n    \"\"\"\n    Read a Fst at a given path.\n    Args:\n      filename: The string location of the input file.\n    Returns:\n      An Fst.\n    Raises:\n      ValueError: Read failed.\n    \"\"\"\n    fst = ctypes.pointer(ctypes.c_void_p())\n    ret_code = lib.vec_fst_from_path(\n        ctypes.byref(fst), str(filename).encode(\"utf-8\")\n    )\n    err_msg = f\"Read failed. file: {filename}\"\n    check_ffi_error(ret_code, err_msg)\n\n    return cls(ptr=fst)\n</code></pre>"},{"location":"rustfst/fst/vector_fst/#rustfst.fst.vector_fst.VectorFst.write","title":"<code>write(filename: Union[str, Path])</code>","text":"<p>Serializes FST to a file. This method writes the FST to a file in vector binary format. Args:   filename: The string location of the output file. Raises:   ValueError: Write failed.</p> Source code in <code>rustfst/fst/vector_fst.py</code> <pre><code>def write(self, filename: Union[str, Path]):\n    \"\"\"\n    Serializes FST to a file.\n    This method writes the FST to a file in vector binary format.\n    Args:\n      filename: The string location of the output file.\n    Raises:\n      ValueError: Write failed.\n    \"\"\"\n    ret_code = lib.vec_fst_write_file(self.ptr, str(filename).encode(\"utf-8\"))\n    err_msg = f\"Write failed. file: {filename}\"\n    check_ffi_error(ret_code, err_msg)\n</code></pre>"},{"location":"rustfst/fst/vector_fst/#rustfst.fst.vector_fst.VectorFst.from_bytes","title":"<code>from_bytes(data: bytes) -&gt; VectorFst</code>  <code>classmethod</code>","text":"<p>Load a <code>VectorFst</code> from a sequence of bytes. Args:     data: Sequence of bytes.</p> <p>Returns:</p> Type Description <code>VectorFst</code> <p>Loaded <code>VectorFst</code>.</p> Source code in <code>rustfst/fst/vector_fst.py</code> <pre><code>@classmethod\ndef from_bytes(cls, data: bytes) -&gt; VectorFst:\n    \"\"\"\n    Load a `VectorFst` from a sequence of bytes.\n    Args:\n        data: Sequence of bytes.\n\n    Returns:\n        Loaded `VectorFst`.\n    \"\"\"\n    fst_ptr = ctypes.pointer(ctypes.c_void_p())\n\n    # Define a temporary struct to hold the bytes array\n    class BytesArray(ctypes.Structure):\n        _fields_ = [(\"data_ptr\", ctypes.c_char_p), (\"size\", ctypes.c_size_t)]\n\n    c_bytes = BytesArray(data, len(data))\n\n    ret_code = lib.vec_fst_from_bytes(ctypes.byref(c_bytes), ctypes.byref(fst_ptr))\n    error_msg = \"`from_bytes` failed\"\n    check_ffi_error(ret_code, error_msg)\n\n    return VectorFst(ptr=fst_ptr)\n</code></pre>"},{"location":"rustfst/fst/vector_fst/#rustfst.fst.vector_fst.VectorFst.to_bytes","title":"<code>to_bytes() -&gt; bytes</code>","text":"<p>Turns the <code>VectorFst</code> into bytes. Returns:     Sequence of bytes.</p> Source code in <code>rustfst/fst/vector_fst.py</code> <pre><code>def to_bytes(self) -&gt; bytes:\n    \"\"\"\n    Turns the `VectorFst` into bytes.\n    Returns:\n        Sequence of bytes.\n    \"\"\"\n\n    # Define a temporary struct to hold the bytes array\n    class BytesArray(ctypes.Structure):\n        _fields_ = [(\"data_ptr\", ctypes.c_void_p), (\"size\", ctypes.c_size_t)]\n\n    bytes_ptr = ctypes.pointer(BytesArray())\n\n    ret_code = lib.vec_fst_to_bytes(self.ptr, ctypes.byref(bytes_ptr))\n    error_msg = \"`to_bytes` failed\"\n    check_ffi_error(ret_code, error_msg)\n\n    return bytes(\n        [\n            ctypes.c_ubyte.from_address(bytes_ptr.contents.data_ptr + i).value\n            for i in range(bytes_ptr.contents.size)\n        ]\n    )\n</code></pre>"},{"location":"rustfst/fst/vector_fst/#rustfst.fst.vector_fst.VectorFst.equals","title":"<code>equals(other: Fst) -&gt; bool</code>","text":"<p>Check if this Fst is equal to the other. Args:     other: Fst instance Returns:      Whether both Fst are equals.</p> Source code in <code>rustfst/fst/vector_fst.py</code> <pre><code>def equals(self, other: Fst) -&gt; bool:\n    \"\"\"\n    Check if this Fst is equal to the other.\n    Args:\n        other: Fst instance\n    Returns:\n         Whether both Fst are equals.\n    \"\"\"\n    is_equal = ctypes.c_size_t()\n\n    ret_code = lib.vec_fst_equals(self.ptr, other.ptr, ctypes.byref(is_equal))\n    err_msg = \"Error checking equality\"\n    check_ffi_error(ret_code, err_msg)\n\n    return bool(is_equal.value)\n</code></pre>"},{"location":"rustfst/fst/vector_fst/#rustfst.fst.vector_fst.VectorFst.copy","title":"<code>copy() -&gt; VectorFst</code>","text":"<p>Returns:</p> Type Description <code>VectorFst</code> <p>A copy of the Fst.</p> Source code in <code>rustfst/fst/vector_fst.py</code> <pre><code>def copy(self) -&gt; VectorFst:\n    \"\"\"\n    Returns:\n        A copy of the Fst.\n    \"\"\"\n    cloned_fst = ctypes.pointer(ctypes.c_void_p())\n    ret_code = lib.vec_fst_copy(self.ptr, ctypes.byref(cloned_fst))\n    err_msg = \"Error copying fst\"\n    check_ffi_error(ret_code, err_msg)\n\n    return VectorFst(cloned_fst)\n</code></pre>"},{"location":"rustfst/fst/vector_fst/#rustfst.fst.vector_fst.VectorFst.compose","title":"<code>compose(other: VectorFst, config: Union[ComposeConfig, None] = None) -&gt; VectorFst</code>","text":"<p>Compute composition of this Fst with another Fst, returning the resulting Fst. Args:     other: Fst to compose with.     config: Config parameters of the composition. Returns:     The composed Fst.</p> Source code in <code>rustfst/fst/vector_fst.py</code> <pre><code>def compose(\n    self, other: VectorFst, config: Union[ComposeConfig, None] = None\n) -&gt; VectorFst:\n    \"\"\"\n    Compute composition of this Fst with another Fst, returning\n    the resulting Fst.\n    Args:\n        other: Fst to compose with.\n        config: Config parameters of the composition.\n    Returns:\n        The composed Fst.\n    \"\"\"\n\n    from rustfst.algorithms.compose import compose, compose_with_config\n\n    if config:\n        return compose_with_config(self, other, config)\n    return compose(self, other)\n</code></pre>"},{"location":"rustfst/fst/vector_fst/#rustfst.fst.vector_fst.VectorFst.concat","title":"<code>concat(other: VectorFst) -&gt; VectorFst</code>","text":"<p>Compute Fst Concatenation of this Fst with another Fst, returning the resulting Fst. Args:     other: Fst to concatenate with.</p> <p>Returns:</p> Type Description <code>VectorFst</code> <p>The concatenated Fst.</p> Source code in <code>rustfst/fst/vector_fst.py</code> <pre><code>def concat(self, other: VectorFst) -&gt; VectorFst:\n    \"\"\"\n    Compute Fst Concatenation of this Fst with another Fst, returning the\n    resulting Fst.\n    Args:\n        other: Fst to concatenate with.\n\n    Returns:\n        The concatenated Fst.\n\n    \"\"\"\n    from rustfst.algorithms.concat import concat\n\n    return concat(self, other)\n</code></pre>"},{"location":"rustfst/fst/vector_fst/#rustfst.fst.vector_fst.VectorFst.connect","title":"<code>connect() -&gt; VectorFst</code>","text":"<p>This operation trims an Fst in-place, removing states and trs that are not on successful paths.</p> <p>Examples :</p> <ul> <li>Input</li> </ul> <p></p> <ul> <li>Output</li> </ul> <p></p> <p>Returns:</p> Type Description <code>VectorFst</code> <p>self</p> Source code in <code>rustfst/fst/vector_fst.py</code> <pre><code>def connect(self) -&gt; VectorFst:\n    \"\"\"\n    This operation trims an Fst in-place, removing states and trs that are\n    not on successful paths.\n\n    Examples :\n\n    - Input\n\n    ![connect_in](https://raw.githubusercontent.com/Garvys/rustfst-images-doc/master/images/connect_in.svg?sanitize=true)\n\n    - Output\n\n    ![connect_out](https://raw.githubusercontent.com/Garvys/rustfst-images-doc/master/images/connect_out.svg?sanitize=true)\n\n    Returns:\n        self\n    \"\"\"\n    from rustfst.algorithms.connect import connect\n\n    return connect(self)\n</code></pre>"},{"location":"rustfst/fst/vector_fst/#rustfst.fst.vector_fst.VectorFst.top_sort","title":"<code>top_sort() -&gt; VectorFst</code>","text":"<p>This operation topologically sorts its input. When sorted, all transitions are from lower to higher state IDs.</p> <p>Examples :</p> <ul> <li>Input</li> </ul> <p></p> <ul> <li>Output</li> </ul> <p></p> <p>Returns:</p> Type Description <code>VectorFst</code> <p>Equivalent top sorted Fst. Modification also happens in-place.</p> Source code in <code>rustfst/fst/vector_fst.py</code> <pre><code>def top_sort(self) -&gt; VectorFst:\n    \"\"\"\n    This operation topologically sorts its input. When sorted, all transitions are from\n    lower to higher state IDs.\n\n    Examples :\n\n    - Input\n\n    ![topsort_in](https://raw.githubusercontent.com/Garvys/rustfst-images-doc/master/images/topsort_in.svg?sanitize=true)\n\n    - Output\n\n    ![topsort_out](https://raw.githubusercontent.com/Garvys/rustfst-images-doc/master/images/topsort_out.svg?sanitize=true)\n\n    Returns:\n        Equivalent top sorted Fst. Modification also happens in-place.\n    \"\"\"\n    from rustfst.algorithms.top_sort import top_sort\n\n    return top_sort(self)\n</code></pre>"},{"location":"rustfst/fst/vector_fst/#rustfst.fst.vector_fst.VectorFst.determinize","title":"<code>determinize(config: Union[DeterminizeConfig, None] = None) -&gt; VectorFst</code>","text":"<p>Make an Fst deterministic Args:     config: Configuration for the determinization operation. Returns:     The resulting Fst.</p> Source code in <code>rustfst/fst/vector_fst.py</code> <pre><code>def determinize(self, config: Union[DeterminizeConfig, None] = None) -&gt; VectorFst:\n    \"\"\"\n    Make an Fst deterministic\n    Args:\n        config: Configuration for the determinization operation.\n    Returns:\n        The resulting Fst.\n    \"\"\"\n    from rustfst.algorithms.determinize import determinize, determinize_with_config\n\n    if config:\n        return determinize_with_config(self, config)\n    return determinize(self)\n</code></pre>"},{"location":"rustfst/fst/vector_fst/#rustfst.fst.vector_fst.VectorFst.minimize","title":"<code>minimize(config: Union[MinimizeConfig, None] = None) -&gt; VectorFst</code>","text":"<p>Minimize an FST in place Args:   config: Configuration for the minimization operation. Returns:   self</p> Source code in <code>rustfst/fst/vector_fst.py</code> <pre><code>def minimize(self, config: Union[MinimizeConfig, None] = None) -&gt; VectorFst:\n    \"\"\"\n    Minimize an FST in place\n    Args:\n      config: Configuration for the minimization operation.\n    Returns:\n      self\n    \"\"\"\n    from rustfst.algorithms.minimize import minimize, minimize_with_config\n\n    if config:\n        return minimize_with_config(self, config)\n    return minimize(self)\n</code></pre>"},{"location":"rustfst/fst/vector_fst/#rustfst.fst.vector_fst.VectorFst.project","title":"<code>project(proj_type: Union[ProjectType, None] = None) -&gt; VectorFst</code>","text":"<p>Convert a Fst to an acceptor using input or output labels. Args:     proj_type: Whether to replace input labels or output labels. Returns:     self</p> Source code in <code>rustfst/fst/vector_fst.py</code> <pre><code>def project(self, proj_type: Union[ProjectType, None] = None) -&gt; VectorFst:\n    \"\"\"\n    Convert a Fst to an acceptor using input or output labels.\n    Args:\n        proj_type: Whether to replace input labels or output labels.\n    Returns:\n        self\n    \"\"\"\n    from rustfst.algorithms.project import project, ProjectType  # noqa: W0621\n\n    if proj_type:\n        return project(self, proj_type)\n    proj_type = ProjectType.PROJECT_INPUT\n    return project(self, proj_type)\n</code></pre>"},{"location":"rustfst/fst/vector_fst/#rustfst.fst.vector_fst.VectorFst.replace","title":"<code>replace(root_label: int, fst_list: List[Tuple[int, VectorFst]], epsilon_on_replace: bool = False) -&gt; VectorFst</code>","text":"<p>Recursively replaces trs in the root FSTs with other FSTs.</p> <p>Replace supports replacement of trs in one Fst with another FST. This replacement is recursive. Replace takes an array of FST(s). The FST on which this method is called represents the root (or topology) machine. The root FST refers to other FSTs by recursively replacing trs labeled as non-terminals with the matching non-terminal FST. Currently Replace uses the output symbols of the trs to determine whether the transition is a non-terminal transition or not. A non-terminal can be any label that is not a non-zero terminal label in the output alphabet.</p> <p>Note that input argument is a vector of pairs. These correspond to the tuple of non-terminal Label and corresponding FST.</p> <p>Examples:</p> <ul> <li>Root Fst :</li> </ul> <p></p> <ul> <li>Fst for non-terminal #NAME :</li> </ul> <p></p> <ul> <li>Fst for non-terminal #FIRSTNAME :</li> </ul> <p></p> <ul> <li>Fst for non-terminal #LASTNAME :</li> </ul> <p></p> <ul> <li>Output :</li> </ul> <p></p> <p>Parameters:</p> Name Type Description Default <code>root_label</code> <code>int</code> <p>Label for self</p> required <code>fst_list</code> <code>List[Tuple[int, VectorFst]]</code> <p>Other FSTs</p> required <code>epsilon_on_replace</code> <code>bool</code> <code>False</code> <p>Returns:</p> Type Description <code>VectorFst</code> <p>The resulting Fst.</p> Source code in <code>rustfst/fst/vector_fst.py</code> <pre><code>def replace(\n    self,\n    root_label: int,\n    fst_list: List[Tuple[int, VectorFst]],\n    epsilon_on_replace: bool = False,\n) -&gt; VectorFst:\n    \"\"\"Recursively replaces trs in the root FSTs with other FSTs.\n\n    Replace supports replacement of trs in one Fst with another\n    FST. This replacement is recursive. Replace takes an array of\n    FST(s). The FST on which this method is called represents the\n    root (or topology) machine. The root FST refers to other FSTs\n    by recursively replacing trs labeled as non-terminals with the\n    matching non-terminal FST. Currently Replace uses the output\n    symbols of the trs to determine whether the transition is a\n    non-terminal transition or not. A non-terminal can be any\n    label that is not a non-zero terminal label in the output\n    alphabet.\n\n    Note that input argument is a vector of pairs. These\n    correspond to the tuple of non-terminal Label and\n    corresponding FST.\n\n    Examples:\n\n    - Root Fst :\n\n    ![replace_in_1](https://raw.githubusercontent.com/Garvys/rustfst-images-doc/master/images/replace_in_1.svg?sanitize=true)\n\n    - Fst for non-terminal #NAME :\n\n    ![replace_in_2](https://raw.githubusercontent.com/Garvys/rustfst-images-doc/master/images/replace_in_2.svg?sanitize=true)\n\n    - Fst for non-terminal #FIRSTNAME :\n\n    ![replace_in_3](https://raw.githubusercontent.com/Garvys/rustfst-images-doc/master/images/replace_in_3.svg?sanitize=true)\n\n    - Fst for non-terminal #LASTNAME :\n\n    ![replace_in_4](https://raw.githubusercontent.com/Garvys/rustfst-images-doc/master/images/replace_in_4.svg?sanitize=true)\n\n    - Output :\n\n    ![replace_out](https://raw.githubusercontent.com/Garvys/rustfst-images-doc/master/images/replace_out.svg?sanitize=true)\n\n    Args:\n        root_label: Label for self\n        fst_list: Other FSTs\n        epsilon_on_replace:\n\n    Returns:\n        The resulting Fst.\n\n    \"\"\"\n    from rustfst.algorithms.replace import replace\n\n    complete_fst_list = [(root_label, self)] + fst_list\n    return replace(root_label, complete_fst_list, epsilon_on_replace)\n</code></pre>"},{"location":"rustfst/fst/vector_fst/#rustfst.fst.vector_fst.VectorFst.reverse","title":"<code>reverse() -&gt; VectorFst</code>","text":"<p>Reverse an Fst, returning a new Fst which accepts the same language in reverse order.</p> <p>Returns:</p> Type Description <code>VectorFst</code> <p>Newly created, reversed Fst.</p> Source code in <code>rustfst/fst/vector_fst.py</code> <pre><code>def reverse(self) -&gt; VectorFst:\n    \"\"\"\n    Reverse an Fst, returning a new Fst which accepts\n    the same language in reverse order.\n\n    Returns:\n      Newly created, reversed Fst.\n    \"\"\"\n    from rustfst.algorithms.reverse import reverse\n\n    return reverse(self)\n</code></pre>"},{"location":"rustfst/fst/vector_fst/#rustfst.fst.vector_fst.VectorFst.rm_epsilon","title":"<code>rm_epsilon() -&gt; VectorFst</code>","text":"<p>Remove epsilon transitions in-place. Returns:   self: Same FST, modified in place</p> Source code in <code>rustfst/fst/vector_fst.py</code> <pre><code>def rm_epsilon(self) -&gt; VectorFst:\n    \"\"\"\n    Remove epsilon transitions in-place.\n    Returns:\n      self: Same FST, modified in place\n    \"\"\"\n    from rustfst.algorithms.rm_epsilon import rm_epsilon\n\n    return rm_epsilon(self)\n</code></pre>"},{"location":"rustfst/fst/vector_fst/#rustfst.fst.vector_fst.VectorFst.shortest_path","title":"<code>shortest_path(config: Union[ShortestPathConfig, None] = None) -&gt; VectorFst</code>","text":"<p>Construct a FST containing the shortest path of the input FST Args:   config: Configuration for shortest-path operation. Returns:   Newly-created FST containing only the shortest path of the input FST.</p> Source code in <code>rustfst/fst/vector_fst.py</code> <pre><code>def shortest_path(\n    self, config: Union[ShortestPathConfig, None] = None\n) -&gt; VectorFst:\n    \"\"\"\n    Construct a FST containing the shortest path of the input FST\n    Args:\n      config: Configuration for shortest-path operation.\n    Returns:\n      Newly-created FST containing only the shortest path of the input FST.\n    \"\"\"\n    from rustfst.algorithms.shortest_path import (\n        shortestpath,\n        shortestpath_with_config,\n    )\n\n    if config:\n        return shortestpath_with_config(self, config)\n    return shortestpath(self)\n</code></pre>"},{"location":"rustfst/fst/vector_fst/#rustfst.fst.vector_fst.VectorFst.union","title":"<code>union(other_fst: VectorFst) -&gt; VectorFst</code>","text":"<p>Performs the union of two wFSTs. If A transduces string <code>x</code> to <code>y</code> with weight <code>a</code> and <code>B</code> transduces string <code>w</code> to <code>v</code> with weight <code>b</code>, then their union transduces <code>x</code> to <code>y</code> with weight <code>a</code> and <code>w</code> to <code>v</code> with weight <code>b</code>.</p> <p>Examples: - Input Fst 1:</p> <p></p> <ul> <li>Input Fst 2:</li> </ul> <p></p> <ul> <li>Union:</li> </ul> <p></p> <p>Parameters:</p> Name Type Description Default <code>other_fst</code> <code>VectorFst</code> <p>Fst to perform union with this one.</p> required <p>Returns:      The resulting newly-created Fst.</p> Source code in <code>rustfst/fst/vector_fst.py</code> <pre><code>def union(self, other_fst: VectorFst) -&gt; VectorFst:\n    \"\"\"\n    Performs the union of two wFSTs. If A transduces string `x` to `y` with weight `a`\n    and `B` transduces string `w` to `v` with weight `b`, then their union transduces `x` to `y`\n    with weight `a` and `w` to `v` with weight `b`.\n\n    Examples:\n    - Input Fst 1:\n\n    ![union_in_1](https://raw.githubusercontent.com/Garvys/rustfst-images-doc/master/images/union_in_1.svg?sanitize=true)\n\n    - Input Fst 2:\n\n    ![union_in_2](https://raw.githubusercontent.com/Garvys/rustfst-images-doc/master/images/union_in_2.svg?sanitize=true)\n\n    - Union:\n\n    ![union_out](https://raw.githubusercontent.com/Garvys/rustfst-images-doc/master/images/union_out.svg?sanitize=true)\n\n    Args:\n        other_fst: Fst to perform union with this one.\n    Returns:\n         The resulting newly-created Fst.\n\n    \"\"\"\n    from rustfst.algorithms.union import union\n\n    return union(self, other_fst)\n</code></pre>"},{"location":"rustfst/fst/vector_fst/#rustfst.fst.vector_fst.VectorFst.optimize","title":"<code>optimize() -&gt; VectorFst</code>","text":"<p>Optimize an FST in-place. Returns:   self</p> Source code in <code>rustfst/fst/vector_fst.py</code> <pre><code>def optimize(self) -&gt; VectorFst:\n    \"\"\"\n    Optimize an FST in-place.\n    Returns:\n      self\n    \"\"\"\n    from rustfst.algorithms.optimize import optimize\n\n    return optimize(self)\n</code></pre>"},{"location":"rustfst/fst/vector_fst/#rustfst.fst.vector_fst.VectorFst.optimize_in_log","title":"<code>optimize_in_log() -&gt; VectorFst</code>","text":"<p>Optimize an fst in-place in the log semiring. Returns:   self</p> Source code in <code>rustfst/fst/vector_fst.py</code> <pre><code>def optimize_in_log(self) -&gt; VectorFst:\n    \"\"\"\n    Optimize an fst in-place in the log semiring.\n    Returns:\n      self\n    \"\"\"\n    from rustfst.algorithms.optimize import optimize_in_log\n\n    return optimize_in_log(self)\n</code></pre>"},{"location":"rustfst/fst/vector_fst/#rustfst.fst.vector_fst.VectorFst.tr_sort","title":"<code>tr_sort(ilabel_cmp: bool = True) -&gt; VectorFst</code>","text":"<p>Sort trs for an FST in-place according to their input or output label.</p> <p>This is often necessary for composition to work properly.  It corresponds to <code>ArcSort</code> in OpenFST.</p> <p>Parameters:</p> Name Type Description Default <code>ilabel_cmp</code> <code>bool</code> <p>Sort on input labels if <code>True</code>, output labels           if <code>False</code>.</p> <code>True</code> <p>Returns:   self</p> Source code in <code>rustfst/fst/vector_fst.py</code> <pre><code>def tr_sort(self, ilabel_cmp: bool = True) -&gt; VectorFst:\n    \"\"\"Sort trs for an FST in-place according to their input or\n    output label.\n\n    This is often necessary for composition to work properly.  It\n    corresponds to `ArcSort` in OpenFST.\n\n    Args:\n      ilabel_cmp: Sort on input labels if `True`, output labels\n                  if `False`.\n    Returns:\n      self\n    \"\"\"\n    from rustfst.algorithms.tr_sort import tr_sort\n\n    return tr_sort(self, ilabel_cmp)\n</code></pre>"},{"location":"rustfst/fst/vector_fst/#rustfst.fst.vector_fst.VectorFst.tr_unique","title":"<code>tr_unique() -&gt; VectorFst</code>","text":"<p>Modify an FST in-place, keeping a single instance of trs leaving the same state, going to the same state and with the same input labels, output labels and weight.</p> <p>Returns:</p> Type Description <code>VectorFst</code> <p>self</p> Source code in <code>rustfst/fst/vector_fst.py</code> <pre><code>def tr_unique(self) -&gt; VectorFst:\n    \"\"\"Modify an FST in-place, keeping a single instance of trs\n    leaving the same state, going to the same state and with the\n    same input labels, output labels and weight.\n\n    Returns:\n      self\n    \"\"\"\n    from rustfst.algorithms.tr_unique import tr_unique\n\n    return tr_unique(self)\n</code></pre>"},{"location":"rustfst/fst/vector_fst/#rustfst.fst.vector_fst.VectorFst.isomorphic","title":"<code>isomorphic(other: VectorFst) -&gt; bool</code>","text":"<p>Check if this Fst is isomorphic with another Args:     other: Other Fst. Returns:     Whether both Fsts are equal.</p> Source code in <code>rustfst/fst/vector_fst.py</code> <pre><code>def isomorphic(self, other: VectorFst) -&gt; bool:\n    \"\"\"\n    Check if this Fst is isomorphic with another\n    Args:\n        other: Other Fst.\n    Returns:\n        Whether both Fsts are equal.\n    \"\"\"\n    from rustfst.algorithms.isomorphic import isomorphic\n\n    return isomorphic(self, other)\n</code></pre>"},{"location":"rustfst/fst/vector_fst/#rustfst.fst.vector_fst.VectorFst.invert","title":"<code>invert() -&gt; VectorFst</code>","text":"<p>Invert the transduction corresponding to an FST by exchanging the FST's input and output labels in-place.</p> <p>Returns:</p> Type Description <code>VectorFst</code> <p>self</p> Source code in <code>rustfst/fst/vector_fst.py</code> <pre><code>def invert(self) -&gt; VectorFst:\n    \"\"\"\n    Invert the transduction corresponding to an FST by exchanging the\n    FST's input and output labels in-place.\n\n    Returns:\n       self\n    \"\"\"\n    from rustfst.algorithms.inversion import invert\n\n    return invert(self)\n</code></pre>"},{"location":"rustfst/fst/vector_fst/#rustfst.fst.vector_fst.VectorFst.__add__","title":"<code>__add__(other: VectorFst) -&gt; VectorFst</code>","text":"<p><code>fst_1 + fst_2</code> is a shortcut to perform the concatenation of <code>fst_1</code> and <code>fst_2</code>. Args:     other: VectorFst to concatenate after the current Fst.</p> <p>Returns:</p> Type Description <code>VectorFst</code> <p>The concatenated Fst.</p> Source code in <code>rustfst/fst/vector_fst.py</code> <pre><code>def __add__(self, other: VectorFst) -&gt; VectorFst:\n    \"\"\"\n    `fst_1 + fst_2` is a shortcut to perform the concatenation of `fst_1` and `fst_2`.\n    Args:\n        other: VectorFst to concatenate after the current Fst.\n\n    Returns:\n        The concatenated Fst.\n    \"\"\"\n    x = self.copy()\n\n    return x.concat(other)\n</code></pre>"},{"location":"rustfst/fst/vector_fst/#rustfst.fst.vector_fst.VectorFst.__mul__","title":"<code>__mul__(other: VectorFst) -&gt; VectorFst</code>","text":"<p><code>fst_1 * fst_2</code> is a shortcut to perform the composition of <code>fst_1</code> and <code>fst_2</code>. Args:     other: VectorFst to compose with.</p> <p>Returns:</p> Type Description <code>VectorFst</code> <p>The composed Fst.</p> Source code in <code>rustfst/fst/vector_fst.py</code> <pre><code>def __mul__(self, other: VectorFst) -&gt; VectorFst:\n    \"\"\"\n    `fst_1 * fst_2` is a shortcut to perform the composition of `fst_1` and `fst_2`.\n    Args:\n        other: VectorFst to compose with.\n\n    Returns:\n        The composed Fst.\n\n    \"\"\"\n    return self.compose(other)\n</code></pre>"},{"location":"rustfst/fst/vector_fst/#rustfst.fst.vector_fst.VectorFst.__or__","title":"<code>__or__(other: VectorFst) -&gt; VectorFst</code>","text":"<p><code>fst_1 | fst_2</code> is a shortcut to perform the union of <code>fst_1</code> and <code>fst_2</code>. Args:     other: VectorFst to perform the union with.</p> <p>Returns:</p> Type Description <code>VectorFst</code> <p>The resulting Fst.</p> Source code in <code>rustfst/fst/vector_fst.py</code> <pre><code>def __or__(self, other: VectorFst) -&gt; VectorFst:\n    \"\"\"\n    `fst_1 | fst_2` is a shortcut to perform the union of `fst_1` and `fst_2`.\n    Args:\n        other: VectorFst to perform the union with.\n\n    Returns:\n        The resulting Fst.\n    \"\"\"\n    x = self.copy()\n\n    return x.union(other)\n</code></pre>"},{"location":"rustfst/fst/vector_fst/#rustfst.fst.vector_fst.VectorFst.string_paths","title":"<code>string_paths() -&gt; StringPathsIterator</code>","text":"<p>Return an iterator over input/output label sequences in this FST, in no particular order.</p> <p>Note that this does not return the best path first.  If you want to do this, you will have to first apply <code>shortest_path</code>.</p> <p>Returns:</p> Type Description <code>StringPathsIterator</code> <p>A iterator over the paths through this FST.</p> Source code in <code>rustfst/fst/vector_fst.py</code> <pre><code>def string_paths(self) -&gt; StringPathsIterator:\n    \"\"\"Return an iterator over input/output label sequences in\n    this FST, *in no particular order*.\n\n    Note that this does not return the best path first.  If you\n    want to do this, you will have to first apply\n    `shortest_path`.\n\n    Returns:\n      A iterator over the paths through this FST.\n    \"\"\"\n    return StringPathsIterator(self)\n</code></pre>"},{"location":"rustfst/fst/vector_fst/#rustfst.fst.vector_fst-functions","title":"Functions","text":""},{"location":"rustfst/iterators/","title":"iterators","text":""},{"location":"rustfst/iterators/#rustfst.iterators-classes","title":"Classes","text":""},{"location":"rustfst/iterators/#rustfst.iterators.TrsIterator","title":"<code>TrsIterator</code>","text":"<p>TrsIterator(fst, state)   This class is used for iterating over the trs leaving some state of a FST.</p> Source code in <code>rustfst/iterators.py</code> <pre><code>class TrsIterator:\n    \"\"\"\n    TrsIterator(fst, state)\n      This class is used for iterating over the trs leaving some state of a FST.\n    \"\"\"\n\n    def __init__(self, fst: Fst, state: int):\n        self.ptr = fst  # reference fst to prolong its lifetime (prevent early gc)\n        state = ctypes.c_size_t(state)\n        iter_ptr = ctypes.pointer(ctypes.c_void_p())\n\n        ret_code = lib.trs_iterator_new(fst.ptr, state, ctypes.byref(iter_ptr))\n        err_msg = \"`__init__` failed\"\n        check_ffi_error(ret_code, err_msg)\n\n        self._ptr = iter_ptr\n\n    def done(self) -&gt; bool:\n        \"\"\"\n        done(self)\n            Indicates whether the iterator is exhausted or not.\n            Returns:\n              True if the iterator is exhausted, False otherwise.\n        \"\"\"\n        done = ctypes.c_size_t()\n\n        ret_code = lib.trs_iterator_done(self._ptr, ctypes.byref(done))\n        err_msg = \"`done` failed\"\n        check_ffi_error(ret_code, err_msg)\n\n        return bool(done.value)\n\n    def __next__(self) -&gt; Optional[Tr]:\n        \"\"\"x.next() -&gt; the next value, or raise StopIteration\"\"\"\n        if self.done():\n            raise StopIteration\n\n        tr_ptr = ctypes.pointer(ctypes.c_void_p())\n        ret_code = lib.trs_iterator_next(self._ptr, ctypes.byref(tr_ptr))\n        err_msg = \"`next` failed\"\n        check_ffi_error(ret_code, err_msg)\n\n        if tr_ptr is None:\n            return None\n\n        return Tr(tr_ptr)\n\n    def reset(self):\n        \"\"\"\n        reset(self)\n            Resets the iterator to the initial position.\n        \"\"\"\n        ret_code = lib.trs_iterator_reset(self._ptr)\n        err_msg = \"`reset` failed\"\n        check_ffi_error(ret_code, err_msg)\n\n    def __iter__(self) -&gt; TrsIterator:\n        \"\"\"x.__iter__() &lt;==&gt; iter(x)\"\"\"\n        return self\n\n    def __repr__(self):\n        \"\"\"x.__repr__() &lt;==&gt; repr(x)\"\"\"\n        return f\"&lt;TrsIterator at 0x{id(self):x}&gt;\"\n\n    def __del__(self):\n        lib.trs_iterator_destroy(self._ptr)\n</code></pre>"},{"location":"rustfst/iterators/#rustfst.iterators.TrsIterator-functions","title":"Functions","text":""},{"location":"rustfst/iterators/#rustfst.iterators.TrsIterator.done","title":"<code>done() -&gt; bool</code>","text":"<p>done(self)     Indicates whether the iterator is exhausted or not.     Returns:       True if the iterator is exhausted, False otherwise.</p> Source code in <code>rustfst/iterators.py</code> <pre><code>def done(self) -&gt; bool:\n    \"\"\"\n    done(self)\n        Indicates whether the iterator is exhausted or not.\n        Returns:\n          True if the iterator is exhausted, False otherwise.\n    \"\"\"\n    done = ctypes.c_size_t()\n\n    ret_code = lib.trs_iterator_done(self._ptr, ctypes.byref(done))\n    err_msg = \"`done` failed\"\n    check_ffi_error(ret_code, err_msg)\n\n    return bool(done.value)\n</code></pre>"},{"location":"rustfst/iterators/#rustfst.iterators.TrsIterator.__next__","title":"<code>__next__() -&gt; Optional[Tr]</code>","text":"<p>x.next() -&gt; the next value, or raise StopIteration</p> Source code in <code>rustfst/iterators.py</code> <pre><code>def __next__(self) -&gt; Optional[Tr]:\n    \"\"\"x.next() -&gt; the next value, or raise StopIteration\"\"\"\n    if self.done():\n        raise StopIteration\n\n    tr_ptr = ctypes.pointer(ctypes.c_void_p())\n    ret_code = lib.trs_iterator_next(self._ptr, ctypes.byref(tr_ptr))\n    err_msg = \"`next` failed\"\n    check_ffi_error(ret_code, err_msg)\n\n    if tr_ptr is None:\n        return None\n\n    return Tr(tr_ptr)\n</code></pre>"},{"location":"rustfst/iterators/#rustfst.iterators.TrsIterator.reset","title":"<code>reset()</code>","text":"<p>reset(self)     Resets the iterator to the initial position.</p> Source code in <code>rustfst/iterators.py</code> <pre><code>def reset(self):\n    \"\"\"\n    reset(self)\n        Resets the iterator to the initial position.\n    \"\"\"\n    ret_code = lib.trs_iterator_reset(self._ptr)\n    err_msg = \"`reset` failed\"\n    check_ffi_error(ret_code, err_msg)\n</code></pre>"},{"location":"rustfst/iterators/#rustfst.iterators.TrsIterator.__iter__","title":"<code>__iter__() -&gt; TrsIterator</code>","text":"<p>x.iter() &lt;==&gt; iter(x)</p> Source code in <code>rustfst/iterators.py</code> <pre><code>def __iter__(self) -&gt; TrsIterator:\n    \"\"\"x.__iter__() &lt;==&gt; iter(x)\"\"\"\n    return self\n</code></pre>"},{"location":"rustfst/iterators/#rustfst.iterators.TrsIterator.__repr__","title":"<code>__repr__()</code>","text":"<p>x.repr() &lt;==&gt; repr(x)</p> Source code in <code>rustfst/iterators.py</code> <pre><code>def __repr__(self):\n    \"\"\"x.__repr__() &lt;==&gt; repr(x)\"\"\"\n    return f\"&lt;TrsIterator at 0x{id(self):x}&gt;\"\n</code></pre>"},{"location":"rustfst/iterators/#rustfst.iterators.MutableTrsIterator","title":"<code>MutableTrsIterator</code>","text":"<p>MutableTrsIterator(ifst, state)   This class is used for iterating over the trs leaving some state of a FST,   also permitting mutation of the current tr.</p> Source code in <code>rustfst/iterators.py</code> <pre><code>class MutableTrsIterator:\n    \"\"\"\n    MutableTrsIterator(ifst, state)\n      This class is used for iterating over the trs leaving some state of a FST,\n      also permitting mutation of the current tr.\n    \"\"\"\n\n    def __init__(self, fst: Fst, state_id: int) -&gt; MutableTrsIterator:\n        self.ptr = fst  # reference fst to prolong its lifetime (prevent early gc)\n        state_id = ctypes.c_size_t(state_id)\n        iter_ptr = ctypes.pointer(ctypes.c_void_p())\n\n        ret_code = lib.mut_trs_iterator_new(fst.ptr, state_id, ctypes.byref(iter_ptr))\n        err_msg = \"`__init__` failed\"\n        check_ffi_error(ret_code, err_msg)\n\n        self._ptr = iter_ptr\n\n    def done(self) -&gt; bool:\n        \"\"\"\n        done(self)\n            Indicates whether the iterator is exhausted or not.\n            Returns:\n              True if the iterator is exhausted, False otherwise.\n        \"\"\"\n        done = ctypes.c_size_t()\n\n        ret_code = lib.mut_trs_iterator_done(self._ptr, ctypes.byref(done))\n        err_msg = \"`done` failed\"\n        check_ffi_error(ret_code, err_msg)\n\n        return bool(done.value)\n\n    def __next__(self):\n        \"\"\"\n        Advances the internal tr iterator.\n        :return: None\n        \"\"\"\n        ret_code = lib.mut_trs_iterator_next(self._ptr)\n        err_msg = \"`next` failed\"\n        check_ffi_error(ret_code, err_msg)\n\n    def reset(self):\n        \"\"\"\n        reset(self)\n            Resets the iterator to the initial position.\n        \"\"\"\n        ret_code = lib.mut_trs_iterator_reset(self._ptr)\n        err_msg = \"`reset`failed\"\n        check_ffi_error(ret_code, err_msg)\n\n    def set_value(self, tr: Tr):\n        \"\"\"\n        set_value(self, tr)\n            Replace the current tr with a new tr.\n            Args:\n              tr: The tr to replace the current tr with.\n        \"\"\"\n        ret_code = lib.mut_trs_iterator_set_value(self._ptr, tr.ptr)\n        err_msg = \"`set_value` failed\"\n        check_ffi_error(ret_code, err_msg)\n\n    def value(self) -&gt; Optional[Tr]:\n        \"\"\"\n        value(self)\n            Returns the current tr.\n        \"\"\"\n        tr_ptr = ctypes.pointer(ctypes.c_void_p())\n        ret_code = lib.mut_trs_iterator_value(self._ptr, ctypes.byref(tr_ptr))\n        err_msg = \"`value` failed\"\n        check_ffi_error(ret_code, err_msg)\n\n        if tr_ptr is None:\n            return None\n\n        return Tr(tr_ptr)\n\n    def __iter__(self) -&gt; MutableTrsIterator:\n        \"\"\"x.__iter__() &lt;==&gt; iter(x)\"\"\"\n        return self\n\n    def __repr__(self):\n        \"\"\"x.__repr__() &lt;==&gt; repr(x)\"\"\"\n        return f\"&lt;MutableTrsIterator at 0x{id(self):x}&gt;\"\n\n    def __del__(self):\n        lib.mut_trs_iterator_destroy(self._ptr)\n</code></pre>"},{"location":"rustfst/iterators/#rustfst.iterators.MutableTrsIterator-functions","title":"Functions","text":""},{"location":"rustfst/iterators/#rustfst.iterators.MutableTrsIterator.done","title":"<code>done() -&gt; bool</code>","text":"<p>done(self)     Indicates whether the iterator is exhausted or not.     Returns:       True if the iterator is exhausted, False otherwise.</p> Source code in <code>rustfst/iterators.py</code> <pre><code>def done(self) -&gt; bool:\n    \"\"\"\n    done(self)\n        Indicates whether the iterator is exhausted or not.\n        Returns:\n          True if the iterator is exhausted, False otherwise.\n    \"\"\"\n    done = ctypes.c_size_t()\n\n    ret_code = lib.mut_trs_iterator_done(self._ptr, ctypes.byref(done))\n    err_msg = \"`done` failed\"\n    check_ffi_error(ret_code, err_msg)\n\n    return bool(done.value)\n</code></pre>"},{"location":"rustfst/iterators/#rustfst.iterators.MutableTrsIterator.__next__","title":"<code>__next__()</code>","text":"<p>Advances the internal tr iterator. :return: None</p> Source code in <code>rustfst/iterators.py</code> <pre><code>def __next__(self):\n    \"\"\"\n    Advances the internal tr iterator.\n    :return: None\n    \"\"\"\n    ret_code = lib.mut_trs_iterator_next(self._ptr)\n    err_msg = \"`next` failed\"\n    check_ffi_error(ret_code, err_msg)\n</code></pre>"},{"location":"rustfst/iterators/#rustfst.iterators.MutableTrsIterator.reset","title":"<code>reset()</code>","text":"<p>reset(self)     Resets the iterator to the initial position.</p> Source code in <code>rustfst/iterators.py</code> <pre><code>def reset(self):\n    \"\"\"\n    reset(self)\n        Resets the iterator to the initial position.\n    \"\"\"\n    ret_code = lib.mut_trs_iterator_reset(self._ptr)\n    err_msg = \"`reset`failed\"\n    check_ffi_error(ret_code, err_msg)\n</code></pre>"},{"location":"rustfst/iterators/#rustfst.iterators.MutableTrsIterator.set_value","title":"<code>set_value(tr: Tr)</code>","text":"<p>set_value(self, tr)     Replace the current tr with a new tr.     Args:       tr: The tr to replace the current tr with.</p> Source code in <code>rustfst/iterators.py</code> <pre><code>def set_value(self, tr: Tr):\n    \"\"\"\n    set_value(self, tr)\n        Replace the current tr with a new tr.\n        Args:\n          tr: The tr to replace the current tr with.\n    \"\"\"\n    ret_code = lib.mut_trs_iterator_set_value(self._ptr, tr.ptr)\n    err_msg = \"`set_value` failed\"\n    check_ffi_error(ret_code, err_msg)\n</code></pre>"},{"location":"rustfst/iterators/#rustfst.iterators.MutableTrsIterator.value","title":"<code>value() -&gt; Optional[Tr]</code>","text":"<p>value(self)     Returns the current tr.</p> Source code in <code>rustfst/iterators.py</code> <pre><code>def value(self) -&gt; Optional[Tr]:\n    \"\"\"\n    value(self)\n        Returns the current tr.\n    \"\"\"\n    tr_ptr = ctypes.pointer(ctypes.c_void_p())\n    ret_code = lib.mut_trs_iterator_value(self._ptr, ctypes.byref(tr_ptr))\n    err_msg = \"`value` failed\"\n    check_ffi_error(ret_code, err_msg)\n\n    if tr_ptr is None:\n        return None\n\n    return Tr(tr_ptr)\n</code></pre>"},{"location":"rustfst/iterators/#rustfst.iterators.MutableTrsIterator.__iter__","title":"<code>__iter__() -&gt; MutableTrsIterator</code>","text":"<p>x.iter() &lt;==&gt; iter(x)</p> Source code in <code>rustfst/iterators.py</code> <pre><code>def __iter__(self) -&gt; MutableTrsIterator:\n    \"\"\"x.__iter__() &lt;==&gt; iter(x)\"\"\"\n    return self\n</code></pre>"},{"location":"rustfst/iterators/#rustfst.iterators.MutableTrsIterator.__repr__","title":"<code>__repr__()</code>","text":"<p>x.repr() &lt;==&gt; repr(x)</p> Source code in <code>rustfst/iterators.py</code> <pre><code>def __repr__(self):\n    \"\"\"x.__repr__() &lt;==&gt; repr(x)\"\"\"\n    return f\"&lt;MutableTrsIterator at 0x{id(self):x}&gt;\"\n</code></pre>"},{"location":"rustfst/iterators/#rustfst.iterators.StateIterator","title":"<code>StateIterator</code>","text":"<p>StateIterator(fst)   This class is used for iterating over the states in a FST.</p> Source code in <code>rustfst/iterators.py</code> <pre><code>class StateIterator:\n    \"\"\"\n    StateIterator(fst)\n      This class is used for iterating over the states in a FST.\n    \"\"\"\n\n    def __init__(self, fst: Fst) -&gt; StateIterator:\n        self.ptr = fst  # reference fst to prolong its lifetime (prevent early gc)\n        iter_ptr = ctypes.pointer(ctypes.c_void_p())\n\n        ret_code = lib.state_iterator_new(fst.ptr, ctypes.byref(iter_ptr))\n        err_msg = \"`__init__` failed\"\n        check_ffi_error(ret_code, err_msg)\n\n        self._ptr = iter_ptr\n\n    def done(self) -&gt; bool:\n        \"\"\"\n        done(self)\n            Indicates whether the iterator is exhausted or not.\n            Returns:\n              True if the iterator is exhausted, False otherwise.\n        \"\"\"\n        done = ctypes.c_size_t()\n\n        ret_code = lib.state_iterator_done(self._ptr, ctypes.byref(done))\n        err_msg = \"`done` failed\"\n        check_ffi_error(ret_code, err_msg)\n\n        return bool(done.value)\n\n    def __next__(self) -&gt; Optional[int]:\n        \"\"\"x.next() -&gt; the next value, or raise StopIteration\"\"\"\n        if self.done():\n            raise StopIteration\n\n        next_state = ctypes.c_size_t()\n        ret_code = lib.state_iterator_next(self._ptr, ctypes.byref(next_state))\n        err_msg = \"`next` failed\"\n        check_ffi_error(ret_code, err_msg)\n\n        if next_state is None:\n            return None\n        return int(next_state.value)\n\n    def __iter__(self) -&gt; StateIterator:\n        \"\"\"x.__iter__() &lt;==&gt; iter(x)\"\"\"\n        return self\n\n    def __repr__(self):\n        \"\"\"x.__repr__() &lt;==&gt; repr(x)\"\"\"\n        return f\"&lt;StateIterator at 0x{id(self):x}&gt;\"\n\n    def __del__(self):\n        lib.state_iterator_destroy(self._ptr)\n</code></pre>"},{"location":"rustfst/iterators/#rustfst.iterators.StateIterator-functions","title":"Functions","text":""},{"location":"rustfst/iterators/#rustfst.iterators.StateIterator.done","title":"<code>done() -&gt; bool</code>","text":"<p>done(self)     Indicates whether the iterator is exhausted or not.     Returns:       True if the iterator is exhausted, False otherwise.</p> Source code in <code>rustfst/iterators.py</code> <pre><code>def done(self) -&gt; bool:\n    \"\"\"\n    done(self)\n        Indicates whether the iterator is exhausted or not.\n        Returns:\n          True if the iterator is exhausted, False otherwise.\n    \"\"\"\n    done = ctypes.c_size_t()\n\n    ret_code = lib.state_iterator_done(self._ptr, ctypes.byref(done))\n    err_msg = \"`done` failed\"\n    check_ffi_error(ret_code, err_msg)\n\n    return bool(done.value)\n</code></pre>"},{"location":"rustfst/iterators/#rustfst.iterators.StateIterator.__next__","title":"<code>__next__() -&gt; Optional[int]</code>","text":"<p>x.next() -&gt; the next value, or raise StopIteration</p> Source code in <code>rustfst/iterators.py</code> <pre><code>def __next__(self) -&gt; Optional[int]:\n    \"\"\"x.next() -&gt; the next value, or raise StopIteration\"\"\"\n    if self.done():\n        raise StopIteration\n\n    next_state = ctypes.c_size_t()\n    ret_code = lib.state_iterator_next(self._ptr, ctypes.byref(next_state))\n    err_msg = \"`next` failed\"\n    check_ffi_error(ret_code, err_msg)\n\n    if next_state is None:\n        return None\n    return int(next_state.value)\n</code></pre>"},{"location":"rustfst/iterators/#rustfst.iterators.StateIterator.__iter__","title":"<code>__iter__() -&gt; StateIterator</code>","text":"<p>x.iter() &lt;==&gt; iter(x)</p> Source code in <code>rustfst/iterators.py</code> <pre><code>def __iter__(self) -&gt; StateIterator:\n    \"\"\"x.__iter__() &lt;==&gt; iter(x)\"\"\"\n    return self\n</code></pre>"},{"location":"rustfst/iterators/#rustfst.iterators.StateIterator.__repr__","title":"<code>__repr__()</code>","text":"<p>x.repr() &lt;==&gt; repr(x)</p> Source code in <code>rustfst/iterators.py</code> <pre><code>def __repr__(self):\n    \"\"\"x.__repr__() &lt;==&gt; repr(x)\"\"\"\n    return f\"&lt;StateIterator at 0x{id(self):x}&gt;\"\n</code></pre>"},{"location":"rustfst/string_path/","title":"string_path","text":""},{"location":"rustfst/string_path/#rustfst.string_path-classes","title":"Classes","text":""},{"location":"rustfst/string_path/#rustfst.string_path.StringPath","title":"<code>StringPath</code>","text":"<p>Struct representing a Path recognized by an Fst allowing to retrieve the input string, the output string and the weight of the Path.</p> Source code in <code>rustfst/string_path.py</code> <pre><code>class StringPath:\n    \"\"\"\n    Struct representing a Path recognized by an Fst allowing to retrieve the input string,\n    the output string and the weight of the Path.\n    \"\"\"\n\n    def __init__(self, ptr):\n        self.ptr = ptr\n\n    def weight(self) -&gt; float:\n        \"\"\"\n        Returns the weight of the path.\n\n        Returns:\n            Weight of the path.\n        \"\"\"\n        weight = ctypes.c_float()\n        ret_code = lib.string_path_weight(self.ptr, ctypes.byref(weight))\n        error_msg = \"`weight` failed\"\n        check_ffi_error(ret_code, error_msg)\n\n        return weight.value\n\n    def istring(self) -&gt; str:\n        \"\"\"\n        Returns the input string of the Path.\n\n        Returns:\n            Input string of the Path.\n        \"\"\"\n        istring = ctypes.c_void_p()\n        ret_code = lib.string_path_istring(self.ptr, ctypes.byref(istring))\n        error_msg = \"`istring` failed\"\n        check_ffi_error(ret_code, error_msg)\n\n        return ctypes.string_at(istring).decode(\"utf8\")\n\n    def ostring(self) -&gt; str:\n        \"\"\"\n        Returns the output string of the Path.\n\n        Returns:\n            Output string of the Path.\n        \"\"\"\n        ostring = ctypes.c_void_p()\n        ret_code = lib.string_path_ostring(self.ptr, ctypes.byref(ostring))\n        error_msg = \"`ostring` failed\"\n        check_ffi_error(ret_code, error_msg)\n\n        return ctypes.string_at(ostring).decode(\"utf8\")\n\n    def __del__(self):\n        lib.string_path_destroy(self.ptr)\n</code></pre>"},{"location":"rustfst/string_path/#rustfst.string_path.StringPath-functions","title":"Functions","text":""},{"location":"rustfst/string_path/#rustfst.string_path.StringPath.weight","title":"<code>weight() -&gt; float</code>","text":"<p>Returns the weight of the path.</p> <p>Returns:</p> Type Description <code>float</code> <p>Weight of the path.</p> Source code in <code>rustfst/string_path.py</code> <pre><code>def weight(self) -&gt; float:\n    \"\"\"\n    Returns the weight of the path.\n\n    Returns:\n        Weight of the path.\n    \"\"\"\n    weight = ctypes.c_float()\n    ret_code = lib.string_path_weight(self.ptr, ctypes.byref(weight))\n    error_msg = \"`weight` failed\"\n    check_ffi_error(ret_code, error_msg)\n\n    return weight.value\n</code></pre>"},{"location":"rustfst/string_path/#rustfst.string_path.StringPath.istring","title":"<code>istring() -&gt; str</code>","text":"<p>Returns the input string of the Path.</p> <p>Returns:</p> Type Description <code>str</code> <p>Input string of the Path.</p> Source code in <code>rustfst/string_path.py</code> <pre><code>def istring(self) -&gt; str:\n    \"\"\"\n    Returns the input string of the Path.\n\n    Returns:\n        Input string of the Path.\n    \"\"\"\n    istring = ctypes.c_void_p()\n    ret_code = lib.string_path_istring(self.ptr, ctypes.byref(istring))\n    error_msg = \"`istring` failed\"\n    check_ffi_error(ret_code, error_msg)\n\n    return ctypes.string_at(istring).decode(\"utf8\")\n</code></pre>"},{"location":"rustfst/string_path/#rustfst.string_path.StringPath.ostring","title":"<code>ostring() -&gt; str</code>","text":"<p>Returns the output string of the Path.</p> <p>Returns:</p> Type Description <code>str</code> <p>Output string of the Path.</p> Source code in <code>rustfst/string_path.py</code> <pre><code>def ostring(self) -&gt; str:\n    \"\"\"\n    Returns the output string of the Path.\n\n    Returns:\n        Output string of the Path.\n    \"\"\"\n    ostring = ctypes.c_void_p()\n    ret_code = lib.string_path_ostring(self.ptr, ctypes.byref(ostring))\n    error_msg = \"`ostring` failed\"\n    check_ffi_error(ret_code, error_msg)\n\n    return ctypes.string_at(ostring).decode(\"utf8\")\n</code></pre>"},{"location":"rustfst/string_paths_iterator/","title":"string_paths_iterator","text":""},{"location":"rustfst/string_paths_iterator/#rustfst.string_paths_iterator-classes","title":"Classes","text":""},{"location":"rustfst/string_paths_iterator/#rustfst.string_paths_iterator.StringPathsIterator","title":"<code>StringPathsIterator</code>","text":"<p>Iterator allowing to loop through all the paths recognized by an Fst.</p> Source code in <code>rustfst/string_paths_iterator.py</code> <pre><code>class StringPathsIterator:\n    \"\"\"\n    Iterator allowing to loop through all the paths recognized by an Fst.\n    \"\"\"\n\n    def __init__(self, fst: VectorFst):\n        \"\"\"\n        Constructor of the Iterator.\n\n        Args:\n            fst: Fst on which we want to loop though the valid paths.\n        \"\"\"\n        self._fst = fst  # reference fst to prolong its lifetime (prevent early gc)\n\n        iter_ptr = ctypes.pointer(ctypes.c_void_p())\n        ret_code = lib.string_paths_iterator_new(fst.ptr, ctypes.byref(iter_ptr))\n        error_msg = \"Something went wrong when creating a StringPathsIterator\"\n        check_ffi_error(ret_code, error_msg)\n\n        self.ptr = iter_ptr\n\n    def __iter__(self):\n        \"\"\" \"\"\"\n        return self\n\n    def __next__(self) -&gt; StringPath:\n        \"\"\" \"\"\"\n        string_path_ptr = ctypes.pointer(ctypes.c_void_p())\n        ret_code = lib.string_paths_iterator_next(\n            self.ptr, ctypes.byref(string_path_ptr)\n        )\n        error_msg = \"`next` failed\"\n        check_ffi_error(ret_code, error_msg)\n\n        if not string_path_ptr:\n            raise StopIteration\n\n        return StringPath(string_path_ptr)\n\n    def done(self) -&gt; bool:\n        \"\"\"\n        Returns whether we're at the end of the Iterator.\n        Returns:\n            True or False\n        \"\"\"\n        done = ctypes.c_size_t()\n\n        ret_code = lib.string_paths_iterator_done(self.ptr, ctypes.byref(done))\n        error_msg = \"`done` failed\"\n        check_ffi_error(ret_code, error_msg)\n\n        return bool(done)\n\n    def __del__(self):\n        if hasattr(self, \"ptr\"):\n            lib.string_paths_iterator_destroy(self.ptr)\n</code></pre>"},{"location":"rustfst/string_paths_iterator/#rustfst.string_paths_iterator.StringPathsIterator-functions","title":"Functions","text":""},{"location":"rustfst/string_paths_iterator/#rustfst.string_paths_iterator.StringPathsIterator.__init__","title":"<code>__init__(fst: VectorFst)</code>","text":"<p>Constructor of the Iterator.</p> <p>Parameters:</p> Name Type Description Default <code>fst</code> <code>VectorFst</code> <p>Fst on which we want to loop though the valid paths.</p> required Source code in <code>rustfst/string_paths_iterator.py</code> <pre><code>def __init__(self, fst: VectorFst):\n    \"\"\"\n    Constructor of the Iterator.\n\n    Args:\n        fst: Fst on which we want to loop though the valid paths.\n    \"\"\"\n    self._fst = fst  # reference fst to prolong its lifetime (prevent early gc)\n\n    iter_ptr = ctypes.pointer(ctypes.c_void_p())\n    ret_code = lib.string_paths_iterator_new(fst.ptr, ctypes.byref(iter_ptr))\n    error_msg = \"Something went wrong when creating a StringPathsIterator\"\n    check_ffi_error(ret_code, error_msg)\n\n    self.ptr = iter_ptr\n</code></pre>"},{"location":"rustfst/string_paths_iterator/#rustfst.string_paths_iterator.StringPathsIterator.__iter__","title":"<code>__iter__()</code>","text":"Source code in <code>rustfst/string_paths_iterator.py</code> <pre><code>def __iter__(self):\n    \"\"\" \"\"\"\n    return self\n</code></pre>"},{"location":"rustfst/string_paths_iterator/#rustfst.string_paths_iterator.StringPathsIterator.__next__","title":"<code>__next__() -&gt; StringPath</code>","text":"Source code in <code>rustfst/string_paths_iterator.py</code> <pre><code>def __next__(self) -&gt; StringPath:\n    \"\"\" \"\"\"\n    string_path_ptr = ctypes.pointer(ctypes.c_void_p())\n    ret_code = lib.string_paths_iterator_next(\n        self.ptr, ctypes.byref(string_path_ptr)\n    )\n    error_msg = \"`next` failed\"\n    check_ffi_error(ret_code, error_msg)\n\n    if not string_path_ptr:\n        raise StopIteration\n\n    return StringPath(string_path_ptr)\n</code></pre>"},{"location":"rustfst/string_paths_iterator/#rustfst.string_paths_iterator.StringPathsIterator.done","title":"<code>done() -&gt; bool</code>","text":"<p>Returns whether we're at the end of the Iterator. Returns:     True or False</p> Source code in <code>rustfst/string_paths_iterator.py</code> <pre><code>def done(self) -&gt; bool:\n    \"\"\"\n    Returns whether we're at the end of the Iterator.\n    Returns:\n        True or False\n    \"\"\"\n    done = ctypes.c_size_t()\n\n    ret_code = lib.string_paths_iterator_done(self.ptr, ctypes.byref(done))\n    error_msg = \"`done` failed\"\n    check_ffi_error(ret_code, error_msg)\n\n    return bool(done)\n</code></pre>"},{"location":"rustfst/symbol_table/","title":"symbol_table","text":""},{"location":"rustfst/symbol_table/#rustfst.symbol_table-classes","title":"Classes","text":""},{"location":"rustfst/symbol_table/#rustfst.symbol_table.SymbolTable","title":"<code>SymbolTable</code>","text":"<p><code>SymbolTable</code> class. This class wraps the <code>SymbolTable</code> struct.</p> Source code in <code>rustfst/symbol_table.py</code> <pre><code>class SymbolTable:\n    \"\"\"\n    `SymbolTable` class. This class wraps the `SymbolTable` struct.\n    \"\"\"\n\n    def __init__(self, ptr=None):\n        \"\"\"\n        Creates an empty `SymbolTable`.\n        \"\"\"\n        if ptr:\n            self.ptr = ptr\n        else:\n            symt_ptr = ctypes.pointer(ctypes.c_void_p())\n            ret_code = lib.symt_new(ctypes.byref(symt_ptr))\n            err_msg = \"__init__ failed\"\n            check_ffi_error(ret_code, err_msg)\n\n            self.ptr = symt_ptr\n\n    def add_symbol(self, symbol: str) -&gt; int:\n        \"\"\"\n        Adds a symbol to the table and returns the index.\n\n        Args:\n          symbol: A symbol unicode string.\n        Returns:\n          The integer key of the new symbol.\n        \"\"\"\n        try:\n            symbol = symbol.encode(\"utf-8\")\n        except UnicodeDecodeError:\n            symbol = ctypes.c_char_p(symbol)\n\n        integer_key = ctypes.c_size_t()\n        ret_code = lib.symt_add_symbol(self.ptr, symbol, ctypes.byref(integer_key))\n        err_msg = \"`add_symbol` failed\"\n        check_ffi_error(ret_code, err_msg)\n\n        return int(integer_key.value)\n\n    def add_table(self, syms: SymbolTable):\n        \"\"\"\n        This method merges another symbol table into the current table. All key\n        values will be offset by the current available key.\n        Args:\n          syms: A `SymbolTable` to be merged with the current table.\n        \"\"\"\n        ret_code = lib.symt_add_table(self.ptr, syms.ptr)\n        err_msg = \"`add_table` failed\"\n        check_ffi_error(ret_code, err_msg)\n\n    def copy(self) -&gt; SymbolTable:\n        \"\"\"\n        Returns:\n            A mutable copy of the `SymbolTable`.\n        \"\"\"\n        clone = ctypes.pointer(ctypes.c_void_p())\n\n        ret_code = lib.symt_copy(self.ptr, ctypes.byref(clone))\n        err_msg = \"`copy` failed.\"\n        check_ffi_error(ret_code, err_msg)\n\n        return SymbolTable(ptr=clone)\n\n    def find(self, key: Union[int, str]) -&gt; Union[int, str]:\n        \"\"\"\n        Given a symbol or index, finds the other one.\n        This method returns the index associated with a symbol key, or the symbol\n        associated with a index key.\n        Args:\n          key: Either a string or an index.\n        Returns:\n          If key is a string, the associated index; if key is an integer, the\n              associated symbol.\n        Raises:\n          KeyError: Key not found.\n        \"\"\"\n        if isinstance(key, int):\n            return self._find_index(key)\n        if isinstance(key, str):\n            return self._find_symbol(key)\n        raise f\"key can only be a string or integer. Not {type(key)}\"\n\n    def _find_index(self, key: int) -&gt; str:\n        key = ctypes.c_size_t(key)\n        symbol = ctypes.c_void_p()\n        ret_code = lib.symt_find_index(self.ptr, key, ctypes.byref(symbol))\n        err_msg = \"`find` failed\"\n        check_ffi_error(ret_code, err_msg)\n\n        return ctypes.string_at(symbol).decode(\"utf8\")\n\n    def _find_symbol(self, symbol: str) -&gt; int:\n        symbol = symbol.encode(\"utf-8\")\n        index = ctypes.c_size_t()\n        ret_code = lib.symt_find_symbol(self.ptr, symbol, ctypes.byref(index))\n        err_msg = \"`find` failed\"\n        check_ffi_error(ret_code, err_msg)\n\n        return int(index.value)\n\n    def member(self, key: Union[int, str]) -&gt; bool:\n        \"\"\"\n        Given a symbol or index, returns whether it is found in the table.\n        This method returns a boolean indicating whether the given symbol or index\n        is present in the table. If one intends to perform subsequent lookup, it is\n        better to simply call the find method, catching the KeyError.\n        Args:\n          key: Either a string or an index.\n        Returns:\n          Whether or not the key is present (as a string or a index) in the table.\n        \"\"\"\n        is_present = ctypes.c_size_t()\n\n        ret_code = None\n\n        if isinstance(key, int):\n            index = ctypes.c_size_t(key)\n            ret_code = lib.symt_member_index(self.ptr, index, ctypes.byref(is_present))\n        elif isinstance(key, str):\n            symbol = key.encode(\"utf-8\")\n            ret_code = lib.symt_member_symbol(\n                self.ptr, symbol, ctypes.byref(is_present)\n            )\n        else:\n            raise f\"key can only be a string or integer. Not {type(key)}\"\n\n        err_msg = \"`member` failed\"\n        check_ffi_error(ret_code, err_msg)\n\n        return bool(is_present.value)\n\n    def num_symbols(self) -&gt; int:\n        \"\"\"\n        Returns:\n            The number of symbols in the symbol table.\n        \"\"\"\n        num_symbols = ctypes.c_size_t()\n        ret_code = lib.symt_num_symbols(self.ptr, ctypes.byref(num_symbols))\n        err_msg = \"`num_symbols` failed\"\n        check_ffi_error(ret_code, err_msg)\n\n        return int(num_symbols.value)\n\n    @classmethod\n    def read(cls, filename: Union[str, Path]) -&gt; SymbolTable:\n        \"\"\"\n        Reads symbol table from binary file.\n        This class method creates a new SymbolTable from a symbol table binary file.\n        Args:\n          filename: The string location of the input binary file.\n        Returns:\n          A new SymbolTable instance.\n        See also: `SymbolTable.read_fst`, `SymbolTable.read_text`.\n        \"\"\"\n        symt = ctypes.pointer(ctypes.c_void_p())\n        ret_code = lib.symt_from_path(\n            ctypes.byref(symt), str(filename).encode(\"utf-8\"), ctypes.c_size_t(1)\n        )\n\n        err_msg = f\"Read failed for bin file : {filename}\"\n        check_ffi_error(ret_code, err_msg)\n\n        return cls(ptr=symt)\n\n    @classmethod\n    def read_text(cls, filename: Union[str, Path]) -&gt; SymbolTable:\n        \"\"\"\n        Reads symbol table from text file.\n        This class method creates a new SymbolTable from a symbol table text file.\n        Args:\n          filename: The string location of the input text file.\n\n        Returns:\n          A new SymbolTable instance.\n        See also: `SymbolTable.read`, `SymbolTable.read_fst`.\n        \"\"\"\n        symt = ctypes.pointer(ctypes.c_void_p())\n        ret_code = lib.symt_from_path(\n            ctypes.byref(symt), str(filename).encode(\"utf-8\"), ctypes.c_size_t(0)\n        )\n\n        err_msg = f\"Read failed for text file : {filename}\"\n        check_ffi_error(ret_code, err_msg)\n\n        return cls(ptr=symt)\n\n    def write(self, filename: Union[str, Path]):\n        \"\"\"\n        Serializes symbol table to a file.\n        This methods writes the SymbolTable to a file in binary format.\n        Args:\n          filename: The string location of the output file.\n        Raises:\n          FstIOError: Write failed.\n        \"\"\"\n        ret_code = lib.symt_write_file(\n            self.ptr, str(filename).encode(\"utf-8\"), ctypes.c_size_t(1)\n        )\n\n        err_msg = f\"Write failed for bin file : {filename}\"\n        check_ffi_error(ret_code, err_msg)\n\n    def write_text(self, filename: Union[str, Path]):\n        \"\"\"\n        Writes symbol table to text file.\n        This method writes the SymbolTable to a file in human-readable format.\n        Args:\n          filename: The string location of the output file.\n        Raises:\n          FstIOError: Write failed.\n        \"\"\"\n        ret_code = lib.symt_write_file(\n            self.ptr, str(filename).encode(\"utf-8\"), ctypes.c_size_t(0)\n        )\n\n        err_msg = f\"Write failed for text file : {filename}\"\n        check_ffi_error(ret_code, err_msg)\n\n    def equals(self, other: SymbolTable) -&gt; bool:\n        \"\"\"\n        Check if this SymbolTable is equal to the other\n\n        Params:\n            other: SymbolTable instance\n        Returns:\n             bool\n        \"\"\"\n        is_equal = ctypes.c_size_t()\n\n        ret_code = lib.symt_equals(self.ptr, other.ptr, ctypes.byref(is_equal))\n        err_msg = \"Error checking equality\"\n        check_ffi_error(ret_code, err_msg)\n\n        return bool(is_equal.value)\n\n    def __eq__(self, other: SymbolTable) -&gt; bool:\n        \"\"\"\n        Check if this `SymbolTable` is equal to the other\n\n        Params:\n            other: SymbolTable instance\n        Returns:\n             bool\n        \"\"\"\n        return self.equals(other)\n\n    def __iter__(self) -&gt; SymbolTableIterator:\n        \"\"\"\n        Returns an Iterator over the SymbolTable.\n        Returns:\n            An iterator over the SymbolTable.\n        \"\"\"\n        return SymbolTableIterator(self)\n\n    @classmethod\n    def from_symbols(cls, symbols: List[str]) -&gt; SymbolTable:\n        \"\"\"\n        Constructs a SymbolTable from list of strings.\n\n        Args:\n            symbols: List of symbols\n\n        Returns:\n            A new `SymbolTable`.\n        \"\"\"\n        symt = cls()\n\n        for symbol in symbols:\n            symt.add_symbol(symbol)\n\n        return symt\n\n    def __del__(self):\n        lib.symt_destroy(self.ptr)\n</code></pre>"},{"location":"rustfst/symbol_table/#rustfst.symbol_table.SymbolTable-functions","title":"Functions","text":""},{"location":"rustfst/symbol_table/#rustfst.symbol_table.SymbolTable.__init__","title":"<code>__init__(ptr=None)</code>","text":"<p>Creates an empty <code>SymbolTable</code>.</p> Source code in <code>rustfst/symbol_table.py</code> <pre><code>def __init__(self, ptr=None):\n    \"\"\"\n    Creates an empty `SymbolTable`.\n    \"\"\"\n    if ptr:\n        self.ptr = ptr\n    else:\n        symt_ptr = ctypes.pointer(ctypes.c_void_p())\n        ret_code = lib.symt_new(ctypes.byref(symt_ptr))\n        err_msg = \"__init__ failed\"\n        check_ffi_error(ret_code, err_msg)\n\n        self.ptr = symt_ptr\n</code></pre>"},{"location":"rustfst/symbol_table/#rustfst.symbol_table.SymbolTable.add_symbol","title":"<code>add_symbol(symbol: str) -&gt; int</code>","text":"<p>Adds a symbol to the table and returns the index.</p> <p>Parameters:</p> Name Type Description Default <code>symbol</code> <code>str</code> <p>A symbol unicode string.</p> required <p>Returns:   The integer key of the new symbol.</p> Source code in <code>rustfst/symbol_table.py</code> <pre><code>def add_symbol(self, symbol: str) -&gt; int:\n    \"\"\"\n    Adds a symbol to the table and returns the index.\n\n    Args:\n      symbol: A symbol unicode string.\n    Returns:\n      The integer key of the new symbol.\n    \"\"\"\n    try:\n        symbol = symbol.encode(\"utf-8\")\n    except UnicodeDecodeError:\n        symbol = ctypes.c_char_p(symbol)\n\n    integer_key = ctypes.c_size_t()\n    ret_code = lib.symt_add_symbol(self.ptr, symbol, ctypes.byref(integer_key))\n    err_msg = \"`add_symbol` failed\"\n    check_ffi_error(ret_code, err_msg)\n\n    return int(integer_key.value)\n</code></pre>"},{"location":"rustfst/symbol_table/#rustfst.symbol_table.SymbolTable.add_table","title":"<code>add_table(syms: SymbolTable)</code>","text":"<p>This method merges another symbol table into the current table. All key values will be offset by the current available key. Args:   syms: A <code>SymbolTable</code> to be merged with the current table.</p> Source code in <code>rustfst/symbol_table.py</code> <pre><code>def add_table(self, syms: SymbolTable):\n    \"\"\"\n    This method merges another symbol table into the current table. All key\n    values will be offset by the current available key.\n    Args:\n      syms: A `SymbolTable` to be merged with the current table.\n    \"\"\"\n    ret_code = lib.symt_add_table(self.ptr, syms.ptr)\n    err_msg = \"`add_table` failed\"\n    check_ffi_error(ret_code, err_msg)\n</code></pre>"},{"location":"rustfst/symbol_table/#rustfst.symbol_table.SymbolTable.copy","title":"<code>copy() -&gt; SymbolTable</code>","text":"<p>Returns:</p> Type Description <code>SymbolTable</code> <p>A mutable copy of the <code>SymbolTable</code>.</p> Source code in <code>rustfst/symbol_table.py</code> <pre><code>def copy(self) -&gt; SymbolTable:\n    \"\"\"\n    Returns:\n        A mutable copy of the `SymbolTable`.\n    \"\"\"\n    clone = ctypes.pointer(ctypes.c_void_p())\n\n    ret_code = lib.symt_copy(self.ptr, ctypes.byref(clone))\n    err_msg = \"`copy` failed.\"\n    check_ffi_error(ret_code, err_msg)\n\n    return SymbolTable(ptr=clone)\n</code></pre>"},{"location":"rustfst/symbol_table/#rustfst.symbol_table.SymbolTable.find","title":"<code>find(key: Union[int, str]) -&gt; Union[int, str]</code>","text":"<p>Given a symbol or index, finds the other one. This method returns the index associated with a symbol key, or the symbol associated with a index key. Args:   key: Either a string or an index. Returns:   If key is a string, the associated index; if key is an integer, the       associated symbol. Raises:   KeyError: Key not found.</p> Source code in <code>rustfst/symbol_table.py</code> <pre><code>def find(self, key: Union[int, str]) -&gt; Union[int, str]:\n    \"\"\"\n    Given a symbol or index, finds the other one.\n    This method returns the index associated with a symbol key, or the symbol\n    associated with a index key.\n    Args:\n      key: Either a string or an index.\n    Returns:\n      If key is a string, the associated index; if key is an integer, the\n          associated symbol.\n    Raises:\n      KeyError: Key not found.\n    \"\"\"\n    if isinstance(key, int):\n        return self._find_index(key)\n    if isinstance(key, str):\n        return self._find_symbol(key)\n    raise f\"key can only be a string or integer. Not {type(key)}\"\n</code></pre>"},{"location":"rustfst/symbol_table/#rustfst.symbol_table.SymbolTable.member","title":"<code>member(key: Union[int, str]) -&gt; bool</code>","text":"<p>Given a symbol or index, returns whether it is found in the table. This method returns a boolean indicating whether the given symbol or index is present in the table. If one intends to perform subsequent lookup, it is better to simply call the find method, catching the KeyError. Args:   key: Either a string or an index. Returns:   Whether or not the key is present (as a string or a index) in the table.</p> Source code in <code>rustfst/symbol_table.py</code> <pre><code>def member(self, key: Union[int, str]) -&gt; bool:\n    \"\"\"\n    Given a symbol or index, returns whether it is found in the table.\n    This method returns a boolean indicating whether the given symbol or index\n    is present in the table. If one intends to perform subsequent lookup, it is\n    better to simply call the find method, catching the KeyError.\n    Args:\n      key: Either a string or an index.\n    Returns:\n      Whether or not the key is present (as a string or a index) in the table.\n    \"\"\"\n    is_present = ctypes.c_size_t()\n\n    ret_code = None\n\n    if isinstance(key, int):\n        index = ctypes.c_size_t(key)\n        ret_code = lib.symt_member_index(self.ptr, index, ctypes.byref(is_present))\n    elif isinstance(key, str):\n        symbol = key.encode(\"utf-8\")\n        ret_code = lib.symt_member_symbol(\n            self.ptr, symbol, ctypes.byref(is_present)\n        )\n    else:\n        raise f\"key can only be a string or integer. Not {type(key)}\"\n\n    err_msg = \"`member` failed\"\n    check_ffi_error(ret_code, err_msg)\n\n    return bool(is_present.value)\n</code></pre>"},{"location":"rustfst/symbol_table/#rustfst.symbol_table.SymbolTable.num_symbols","title":"<code>num_symbols() -&gt; int</code>","text":"<p>Returns:</p> Type Description <code>int</code> <p>The number of symbols in the symbol table.</p> Source code in <code>rustfst/symbol_table.py</code> <pre><code>def num_symbols(self) -&gt; int:\n    \"\"\"\n    Returns:\n        The number of symbols in the symbol table.\n    \"\"\"\n    num_symbols = ctypes.c_size_t()\n    ret_code = lib.symt_num_symbols(self.ptr, ctypes.byref(num_symbols))\n    err_msg = \"`num_symbols` failed\"\n    check_ffi_error(ret_code, err_msg)\n\n    return int(num_symbols.value)\n</code></pre>"},{"location":"rustfst/symbol_table/#rustfst.symbol_table.SymbolTable.read","title":"<code>read(filename: Union[str, Path]) -&gt; SymbolTable</code>  <code>classmethod</code>","text":"<p>Reads symbol table from binary file. This class method creates a new SymbolTable from a symbol table binary file. Args:   filename: The string location of the input binary file. Returns:   A new SymbolTable instance. See also: <code>SymbolTable.read_fst</code>, <code>SymbolTable.read_text</code>.</p> Source code in <code>rustfst/symbol_table.py</code> <pre><code>@classmethod\ndef read(cls, filename: Union[str, Path]) -&gt; SymbolTable:\n    \"\"\"\n    Reads symbol table from binary file.\n    This class method creates a new SymbolTable from a symbol table binary file.\n    Args:\n      filename: The string location of the input binary file.\n    Returns:\n      A new SymbolTable instance.\n    See also: `SymbolTable.read_fst`, `SymbolTable.read_text`.\n    \"\"\"\n    symt = ctypes.pointer(ctypes.c_void_p())\n    ret_code = lib.symt_from_path(\n        ctypes.byref(symt), str(filename).encode(\"utf-8\"), ctypes.c_size_t(1)\n    )\n\n    err_msg = f\"Read failed for bin file : {filename}\"\n    check_ffi_error(ret_code, err_msg)\n\n    return cls(ptr=symt)\n</code></pre>"},{"location":"rustfst/symbol_table/#rustfst.symbol_table.SymbolTable.read_text","title":"<code>read_text(filename: Union[str, Path]) -&gt; SymbolTable</code>  <code>classmethod</code>","text":"<p>Reads symbol table from text file. This class method creates a new SymbolTable from a symbol table text file. Args:   filename: The string location of the input text file.</p> <p>Returns:</p> Type Description <code>SymbolTable</code> <p>A new SymbolTable instance.</p> <p>See also: <code>SymbolTable.read</code>, <code>SymbolTable.read_fst</code>.</p> Source code in <code>rustfst/symbol_table.py</code> <pre><code>@classmethod\ndef read_text(cls, filename: Union[str, Path]) -&gt; SymbolTable:\n    \"\"\"\n    Reads symbol table from text file.\n    This class method creates a new SymbolTable from a symbol table text file.\n    Args:\n      filename: The string location of the input text file.\n\n    Returns:\n      A new SymbolTable instance.\n    See also: `SymbolTable.read`, `SymbolTable.read_fst`.\n    \"\"\"\n    symt = ctypes.pointer(ctypes.c_void_p())\n    ret_code = lib.symt_from_path(\n        ctypes.byref(symt), str(filename).encode(\"utf-8\"), ctypes.c_size_t(0)\n    )\n\n    err_msg = f\"Read failed for text file : {filename}\"\n    check_ffi_error(ret_code, err_msg)\n\n    return cls(ptr=symt)\n</code></pre>"},{"location":"rustfst/symbol_table/#rustfst.symbol_table.SymbolTable.write","title":"<code>write(filename: Union[str, Path])</code>","text":"<p>Serializes symbol table to a file. This methods writes the SymbolTable to a file in binary format. Args:   filename: The string location of the output file. Raises:   FstIOError: Write failed.</p> Source code in <code>rustfst/symbol_table.py</code> <pre><code>def write(self, filename: Union[str, Path]):\n    \"\"\"\n    Serializes symbol table to a file.\n    This methods writes the SymbolTable to a file in binary format.\n    Args:\n      filename: The string location of the output file.\n    Raises:\n      FstIOError: Write failed.\n    \"\"\"\n    ret_code = lib.symt_write_file(\n        self.ptr, str(filename).encode(\"utf-8\"), ctypes.c_size_t(1)\n    )\n\n    err_msg = f\"Write failed for bin file : {filename}\"\n    check_ffi_error(ret_code, err_msg)\n</code></pre>"},{"location":"rustfst/symbol_table/#rustfst.symbol_table.SymbolTable.write_text","title":"<code>write_text(filename: Union[str, Path])</code>","text":"<p>Writes symbol table to text file. This method writes the SymbolTable to a file in human-readable format. Args:   filename: The string location of the output file. Raises:   FstIOError: Write failed.</p> Source code in <code>rustfst/symbol_table.py</code> <pre><code>def write_text(self, filename: Union[str, Path]):\n    \"\"\"\n    Writes symbol table to text file.\n    This method writes the SymbolTable to a file in human-readable format.\n    Args:\n      filename: The string location of the output file.\n    Raises:\n      FstIOError: Write failed.\n    \"\"\"\n    ret_code = lib.symt_write_file(\n        self.ptr, str(filename).encode(\"utf-8\"), ctypes.c_size_t(0)\n    )\n\n    err_msg = f\"Write failed for text file : {filename}\"\n    check_ffi_error(ret_code, err_msg)\n</code></pre>"},{"location":"rustfst/symbol_table/#rustfst.symbol_table.SymbolTable.equals","title":"<code>equals(other: SymbolTable) -&gt; bool</code>","text":"<p>Check if this SymbolTable is equal to the other</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>SymbolTable</code> <p>SymbolTable instance</p> required <p>Returns:      bool</p> Source code in <code>rustfst/symbol_table.py</code> <pre><code>def equals(self, other: SymbolTable) -&gt; bool:\n    \"\"\"\n    Check if this SymbolTable is equal to the other\n\n    Params:\n        other: SymbolTable instance\n    Returns:\n         bool\n    \"\"\"\n    is_equal = ctypes.c_size_t()\n\n    ret_code = lib.symt_equals(self.ptr, other.ptr, ctypes.byref(is_equal))\n    err_msg = \"Error checking equality\"\n    check_ffi_error(ret_code, err_msg)\n\n    return bool(is_equal.value)\n</code></pre>"},{"location":"rustfst/symbol_table/#rustfst.symbol_table.SymbolTable.__eq__","title":"<code>__eq__(other: SymbolTable) -&gt; bool</code>","text":"<p>Check if this <code>SymbolTable</code> is equal to the other</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>SymbolTable</code> <p>SymbolTable instance</p> required <p>Returns:      bool</p> Source code in <code>rustfst/symbol_table.py</code> <pre><code>def __eq__(self, other: SymbolTable) -&gt; bool:\n    \"\"\"\n    Check if this `SymbolTable` is equal to the other\n\n    Params:\n        other: SymbolTable instance\n    Returns:\n         bool\n    \"\"\"\n    return self.equals(other)\n</code></pre>"},{"location":"rustfst/symbol_table/#rustfst.symbol_table.SymbolTable.__iter__","title":"<code>__iter__() -&gt; SymbolTableIterator</code>","text":"<p>Returns an Iterator over the SymbolTable. Returns:     An iterator over the SymbolTable.</p> Source code in <code>rustfst/symbol_table.py</code> <pre><code>def __iter__(self) -&gt; SymbolTableIterator:\n    \"\"\"\n    Returns an Iterator over the SymbolTable.\n    Returns:\n        An iterator over the SymbolTable.\n    \"\"\"\n    return SymbolTableIterator(self)\n</code></pre>"},{"location":"rustfst/symbol_table/#rustfst.symbol_table.SymbolTable.from_symbols","title":"<code>from_symbols(symbols: List[str]) -&gt; SymbolTable</code>  <code>classmethod</code>","text":"<p>Constructs a SymbolTable from list of strings.</p> <p>Parameters:</p> Name Type Description Default <code>symbols</code> <code>List[str]</code> <p>List of symbols</p> required <p>Returns:</p> Type Description <code>SymbolTable</code> <p>A new <code>SymbolTable</code>.</p> Source code in <code>rustfst/symbol_table.py</code> <pre><code>@classmethod\ndef from_symbols(cls, symbols: List[str]) -&gt; SymbolTable:\n    \"\"\"\n    Constructs a SymbolTable from list of strings.\n\n    Args:\n        symbols: List of symbols\n\n    Returns:\n        A new `SymbolTable`.\n    \"\"\"\n    symt = cls()\n\n    for symbol in symbols:\n        symt.add_symbol(symbol)\n\n    return symt\n</code></pre>"},{"location":"rustfst/symbol_table/#rustfst.symbol_table.SymbolTableIterator","title":"<code>SymbolTableIterator</code>","text":"<p>Iterator on a SymbolTable. Allows retrieving all the symbols along with their corresponding labels.</p> Source code in <code>rustfst/symbol_table.py</code> <pre><code>class SymbolTableIterator:\n    \"\"\"\n    Iterator on a SymbolTable. Allows retrieving all the symbols along with their corresponding labels.\n    \"\"\"\n\n    def __init__(self, symbol_table: SymbolTable):\n        \"\"\"\n        Constructs an iterator from the `Symboltable`.\n        Args:\n            symbol_table:\n        \"\"\"\n        self._symt = symbol_table\n        self._idx = 0\n        self._len = self._symt.num_symbols()\n\n    def __next__(self) -&gt; Tuple[int, str]:\n        \"\"\"\n        Iterator over the symbols in the `SymbolTable`.\n        Returns:\n            A pair label (int) and symbol (str).\n        \"\"\"\n        if self._idx &lt; self._len:\n            output = (self._idx, self._symt.find(self._idx))\n            self._idx += 1\n            return output\n        raise StopIteration\n</code></pre>"},{"location":"rustfst/symbol_table/#rustfst.symbol_table.SymbolTableIterator-functions","title":"Functions","text":""},{"location":"rustfst/symbol_table/#rustfst.symbol_table.SymbolTableIterator.__init__","title":"<code>__init__(symbol_table: SymbolTable)</code>","text":"<p>Constructs an iterator from the <code>Symboltable</code>. Args:     symbol_table:</p> Source code in <code>rustfst/symbol_table.py</code> <pre><code>def __init__(self, symbol_table: SymbolTable):\n    \"\"\"\n    Constructs an iterator from the `Symboltable`.\n    Args:\n        symbol_table:\n    \"\"\"\n    self._symt = symbol_table\n    self._idx = 0\n    self._len = self._symt.num_symbols()\n</code></pre>"},{"location":"rustfst/symbol_table/#rustfst.symbol_table.SymbolTableIterator.__next__","title":"<code>__next__() -&gt; Tuple[int, str]</code>","text":"<p>Iterator over the symbols in the <code>SymbolTable</code>. Returns:     A pair label (int) and symbol (str).</p> Source code in <code>rustfst/symbol_table.py</code> <pre><code>def __next__(self) -&gt; Tuple[int, str]:\n    \"\"\"\n    Iterator over the symbols in the `SymbolTable`.\n    Returns:\n        A pair label (int) and symbol (str).\n    \"\"\"\n    if self._idx &lt; self._len:\n        output = (self._idx, self._symt.find(self._idx))\n        self._idx += 1\n        return output\n    raise StopIteration\n</code></pre>"},{"location":"rustfst/tr/","title":"tr","text":""},{"location":"rustfst/tr/#rustfst.tr-classes","title":"Classes","text":""},{"location":"rustfst/tr/#rustfst.tr.Tr","title":"<code>Tr</code>","text":"<p>Structure representing a transition from a state to another state in a FST. Attributes:     ilabel: The input label.     olabel: The output label.     weight: The transition weight.     nextstate: The destination state for the arc.</p> Source code in <code>rustfst/tr.py</code> <pre><code>class Tr:\n    \"\"\"\n    Structure representing a transition from a state to another state in a FST.\n    Attributes:\n        ilabel: The input label.\n        olabel: The output label.\n        weight: The transition weight.\n        nextstate: The destination state for the arc.\n    \"\"\"\n\n    def __init__(\n        self,\n        ilabel: Optional[int] = None,\n        olabel: Optional[int] = None,\n        weight: Optional[float] = None,\n        nextstate: Optional[int] = None,\n    ):\n        \"\"\"\n        Create a new transition.\n\n        Args:\n            ilabel: The input label.\n            olabel: The outpit label.\n            weight: The transition's weight\n            nextstate: The destination state for the transition.\n        \"\"\"\n        if ilabel and olabel is None and weight is None and nextstate is None:\n            self._ptr = ilabel\n        else:\n            if weight is None:\n                weight = weight_one()\n\n            ptr = c_void_p()\n            exit_code = lib.tr_new(\n                c_size_t(ilabel),\n                c_size_t(olabel),\n                c_float(weight),\n                c_size_t(nextstate),\n                byref(ptr),\n            )\n            err_msg = \"Something went wrong when creating the Tr struct\"\n            check_ffi_error(exit_code, err_msg)\n\n            self._ptr = ptr\n\n    @property\n    def ptr(self):\n        return self._ptr\n\n    @property\n    def ilabel(self) -&gt; int:\n        ilabel = c_size_t()\n        exit_code = lib.tr_ilabel(self._ptr, byref(ilabel))\n        err_msg = \"Something went wrong when reading Tr ilabel value\"\n        check_ffi_error(exit_code, err_msg)\n        return int(ilabel.value)\n\n    @ilabel.setter\n    def ilabel(self, value: int):\n        ilabel = c_size_t(value)\n        exit_code = lib.tr_set_ilabel(self._ptr, ilabel)\n        err_msg = \"Something went wrong when setting Tr ilabel value\"\n        check_ffi_error(exit_code, err_msg)\n\n    @property\n    def olabel(self) -&gt; int:\n        olabel = c_size_t()\n        exit_code = lib.tr_olabel(self._ptr, byref(olabel))\n        err_msg = \"Something went wrong when reading Tr ilabel value\"\n        check_ffi_error(exit_code, err_msg)\n        return int(olabel.value)\n\n    @olabel.setter\n    def olabel(self, value: int):\n        olabel = c_size_t(value)\n        exit_code = lib.tr_set_olabel(self._ptr, olabel)\n        err_msg = \"Something went wrong when setting Tr olabel value\"\n        check_ffi_error(exit_code, err_msg)\n\n    @property\n    def weight(self) -&gt; float:\n        weight = c_float()\n        exit_code = lib.tr_weight(self._ptr, byref(weight))\n        err_msg = \"Something went wrong when reading Tr ilabel value\"\n        check_ffi_error(exit_code, err_msg)\n        return weight.value\n\n    @weight.setter\n    def weight(self, value: float):\n        weight = c_float(value)\n        exit_code = lib.tr_set_weight(self._ptr, weight)\n        err_msg = \"Something went wrong when setting Tr weight value\"\n        check_ffi_error(exit_code, err_msg)\n\n    @property\n    def next_state(self) -&gt; int:\n        next_state = c_size_t()\n        exit_code = lib.tr_next_state(self._ptr, byref(next_state))\n        err_msg = \"Something went wrong when reading Tr ilabel value\"\n        check_ffi_error(exit_code, err_msg)\n        return int(next_state.value)\n\n    @next_state.setter\n    def next_state(self, next_state: int):\n        next_state = c_size_t(next_state)\n        exit_code = lib.tr_set_next_state(self._ptr, next_state)\n        err_msg = \"Something went wrong when setting Tr next_state value\"\n        check_ffi_error(exit_code, err_msg)\n\n    def __eq__(self, other: Tr):\n        return (\n            self.ilabel == other.ilabel\n            and self.olabel == other.olabel\n            and self.weight == other.weight\n            and self.next_state == other.next_state\n        )\n\n    def __repr__(self):\n        \"\"\"x.__repr__() &lt;==&gt; repr(x)\"\"\"\n        return f\"&lt;Tr ilabel={self.ilabel}, olabel={self.olabel}, weight={self.weight}, next_state={self.next_state}&gt;\"\n\n    def __del__(self):\n        lib.tr_delete(self._ptr)\n</code></pre>"},{"location":"rustfst/tr/#rustfst.tr.Tr-functions","title":"Functions","text":""},{"location":"rustfst/tr/#rustfst.tr.Tr.__init__","title":"<code>__init__(ilabel: Optional[int] = None, olabel: Optional[int] = None, weight: Optional[float] = None, nextstate: Optional[int] = None)</code>","text":"<p>Create a new transition.</p> <p>Parameters:</p> Name Type Description Default <code>ilabel</code> <code>Optional[int]</code> <p>The input label.</p> <code>None</code> <code>olabel</code> <code>Optional[int]</code> <p>The outpit label.</p> <code>None</code> <code>weight</code> <code>Optional[float]</code> <p>The transition's weight</p> <code>None</code> <code>nextstate</code> <code>Optional[int]</code> <p>The destination state for the transition.</p> <code>None</code> Source code in <code>rustfst/tr.py</code> <pre><code>def __init__(\n    self,\n    ilabel: Optional[int] = None,\n    olabel: Optional[int] = None,\n    weight: Optional[float] = None,\n    nextstate: Optional[int] = None,\n):\n    \"\"\"\n    Create a new transition.\n\n    Args:\n        ilabel: The input label.\n        olabel: The outpit label.\n        weight: The transition's weight\n        nextstate: The destination state for the transition.\n    \"\"\"\n    if ilabel and olabel is None and weight is None and nextstate is None:\n        self._ptr = ilabel\n    else:\n        if weight is None:\n            weight = weight_one()\n\n        ptr = c_void_p()\n        exit_code = lib.tr_new(\n            c_size_t(ilabel),\n            c_size_t(olabel),\n            c_float(weight),\n            c_size_t(nextstate),\n            byref(ptr),\n        )\n        err_msg = \"Something went wrong when creating the Tr struct\"\n        check_ffi_error(exit_code, err_msg)\n\n        self._ptr = ptr\n</code></pre>"},{"location":"rustfst/tr/#rustfst.tr.Tr.__repr__","title":"<code>__repr__()</code>","text":"<p>x.repr() &lt;==&gt; repr(x)</p> Source code in <code>rustfst/tr.py</code> <pre><code>def __repr__(self):\n    \"\"\"x.__repr__() &lt;==&gt; repr(x)\"\"\"\n    return f\"&lt;Tr ilabel={self.ilabel}, olabel={self.olabel}, weight={self.weight}, next_state={self.next_state}&gt;\"\n</code></pre>"},{"location":"rustfst/tr/#rustfst.tr-functions","title":"Functions","text":""},{"location":"rustfst/trs/","title":"trs","text":""},{"location":"rustfst/trs/#rustfst.trs-classes","title":"Classes","text":""},{"location":"rustfst/trs/#rustfst.trs.Trs","title":"<code>Trs</code>","text":"<p>Structure representing list of transitions.</p> Source code in <code>rustfst/trs.py</code> <pre><code>class Trs:\n    \"\"\"Structure representing list of transitions.\"\"\"\n\n    def __init__(self, ptr=None) -&gt; Trs:\n        \"\"\"\n        Create an empty list of transitions.\n        \"\"\"\n        if ptr is None:\n            self._ptr = c_void_p()\n            exit_code = lib.trs_vec_new(byref(self._ptr))\n            err_msg = \"Something went wrong when creating the Trs struct\"\n            check_ffi_error(exit_code, err_msg)\n        else:\n            self._ptr = ptr\n\n    def push(self, tr: Tr):\n        \"\"\"\n        Add a new transition to the list.\n        Args:\n            tr: The transition to add.\n        \"\"\"\n        exit_code = lib.trs_vec_push(self._ptr, tr.ptr)\n        err_msg = \"Something went wrong when adding new transition\"\n        check_ffi_error(exit_code, err_msg)\n\n    def remove(self, index: int) -&gt; Tr:\n        removed_tr = c_void_p()\n        exit_code = lib.trs_vec_remove(self._ptr, index, byref(removed_tr))\n        err_msg = \"Something went wrong when removing transition at index: \" + str(\n            index\n        )\n        check_ffi_error(exit_code, err_msg)\n        return Tr(removed_tr)\n\n    def len(self) -&gt; int:\n        \"\"\"\n        Compute the number of transitions in the list.\n        Returns:\n            The number of transitions.\n\n        \"\"\"\n        num_trs = c_size_t()\n        ret_code = lib.trs_vec_len(self._ptr, byref(num_trs))\n        err_msg = \"`len` failed\"\n        check_ffi_error(ret_code, err_msg)\n        return int(num_trs.value)\n\n    def shallow_clone(self) -&gt; Trs:\n        new_trs_ptr = c_void_p()\n        exit_code = lib.trs_vec_shallow_clone(self._ptr, new_trs_ptr)\n        err_msg = \"Something went wrong when cloning Trs\"\n        check_ffi_error(exit_code, err_msg)\n\n        return Trs(new_trs_ptr)\n\n    def __repr__(self) -&gt; str:\n        string = c_void_p()\n        exit_code = lib.trs_vec_display(self._ptr, byref(string))\n        err_msg = \"Something went wrong when displaying Trs\"\n        check_ffi_error(exit_code, err_msg)\n        return string_at(string).decode(\"utf8\")\n\n    def __del__(self):\n        lib.trs_vec_delete(self._ptr)\n</code></pre>"},{"location":"rustfst/trs/#rustfst.trs.Trs-functions","title":"Functions","text":""},{"location":"rustfst/trs/#rustfst.trs.Trs.__init__","title":"<code>__init__(ptr=None) -&gt; Trs</code>","text":"<p>Create an empty list of transitions.</p> Source code in <code>rustfst/trs.py</code> <pre><code>def __init__(self, ptr=None) -&gt; Trs:\n    \"\"\"\n    Create an empty list of transitions.\n    \"\"\"\n    if ptr is None:\n        self._ptr = c_void_p()\n        exit_code = lib.trs_vec_new(byref(self._ptr))\n        err_msg = \"Something went wrong when creating the Trs struct\"\n        check_ffi_error(exit_code, err_msg)\n    else:\n        self._ptr = ptr\n</code></pre>"},{"location":"rustfst/trs/#rustfst.trs.Trs.push","title":"<code>push(tr: Tr)</code>","text":"<p>Add a new transition to the list. Args:     tr: The transition to add.</p> Source code in <code>rustfst/trs.py</code> <pre><code>def push(self, tr: Tr):\n    \"\"\"\n    Add a new transition to the list.\n    Args:\n        tr: The transition to add.\n    \"\"\"\n    exit_code = lib.trs_vec_push(self._ptr, tr.ptr)\n    err_msg = \"Something went wrong when adding new transition\"\n    check_ffi_error(exit_code, err_msg)\n</code></pre>"},{"location":"rustfst/trs/#rustfst.trs.Trs.len","title":"<code>len() -&gt; int</code>","text":"<p>Compute the number of transitions in the list. Returns:     The number of transitions.</p> Source code in <code>rustfst/trs.py</code> <pre><code>def len(self) -&gt; int:\n    \"\"\"\n    Compute the number of transitions in the list.\n    Returns:\n        The number of transitions.\n\n    \"\"\"\n    num_trs = c_size_t()\n    ret_code = lib.trs_vec_len(self._ptr, byref(num_trs))\n    err_msg = \"`len` failed\"\n    check_ffi_error(ret_code, err_msg)\n    return int(num_trs.value)\n</code></pre>"},{"location":"rustfst/weight/","title":"weight","text":""},{"location":"rustfst/weight/#rustfst.weight-functions","title":"Functions","text":""},{"location":"rustfst/weight/#rustfst.weight.weight_one","title":"<code>weight_one() -&gt; float</code>","text":"<p>Compute One() in the Tropical Semiring. Returns:     Float value corresponding to One() in the Tropical Semiring.</p> Source code in <code>rustfst/weight.py</code> <pre><code>def weight_one() -&gt; float:\n    \"\"\"\n    Compute One() in the Tropical Semiring.\n    Returns:\n        Float value corresponding to One() in the Tropical Semiring.\n    \"\"\"\n    weight = ctypes.c_float()\n    ret_code = lib.fst_weight_one(ctypes.byref(weight))\n    err_msg = \"weight_one failed\"\n    check_ffi_error(ret_code, err_msg)\n    return float(weight.value)\n</code></pre>"},{"location":"rustfst/weight/#rustfst.weight.weight_zero","title":"<code>weight_zero() -&gt; float</code>","text":"<p>Compute Zero() in the Tropical Semiring. Returns:     Float value corresponding to Zero() in the Tropical Semiring.</p> Source code in <code>rustfst/weight.py</code> <pre><code>def weight_zero() -&gt; float:\n    \"\"\"\n    Compute Zero() in the Tropical Semiring.\n    Returns:\n        Float value corresponding to Zero() in the Tropical Semiring.\n    \"\"\"\n    weight = ctypes.c_float()\n    ret_code = lib.fst_weight_zero(ctypes.byref(weight))\n    err_msg = \"weight_zero failed\"\n    check_ffi_error(ret_code, err_msg)\n    return float(weight.value)\n</code></pre>"}]}